<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://aloerina01.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://aloerina01.github.io/" rel="alternate" type="text/html" /><updated>2020-04-21T09:05:56+00:00</updated><id>https://aloerina01.github.io/feed.xml</id><title type="html">mille-feuille code</title><subtitle>Web Developer。同じような過ちを繰り返さないように備忘録を残しています。
</subtitle><entry><title type="html">わたしのふりかえりデザインテンプレート</title><link href="https://aloerina01.github.io/blog/2020-04-16-1" rel="alternate" type="text/html" title="わたしのふりかえりデザインテンプレート" /><published>2020-04-16T00:00:00+00:00</published><updated>2020-04-16T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2020-04-16-1">&lt;p&gt;私の関わるいくつかのチームではよく&lt;strong&gt;ふりかえり&lt;/strong&gt;をします。ScrumチームがSprint毎に行う「Sprint Retrospective」であったり、フロントエンドエンジニアのチームが隔週で行う「カイゼンミーティング」であったり、呼び名や頻度や内容は様々ですが、定期的に&lt;strong&gt;自分たちの行動を思い返し何らかの学びを得る活動&lt;/strong&gt;をしています。&lt;/p&gt;

&lt;p&gt;今回は、これらのふりかえりを私がどのように設計しているかについて、ふりかえってみようと思います。せっかくなのでテンプレートという形で書き出してみます。&lt;/p&gt;

&lt;p&gt;ちなみにこの記事では「過去のある期間を振り返って気づきや学びを得て、今後の行動に反映する一連の活動」を &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ふりかえり&lt;/code&gt;&lt;/strong&gt; と呼び、ふりかえりの一貫として開催されるミーティングを &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ふりかえりミーティング&lt;/code&gt;&lt;/strong&gt; と呼び分けることとします。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ふりかえりの大枠をデザインする&quot; id=&quot;markdown-toc-ふりかえりの大枠をデザインする&quot;&gt;ふりかえりの大枠をデザインする&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ふりかえりの目的&quot; id=&quot;markdown-toc-ふりかえりの目的&quot;&gt;ふりかえりの目的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ふりかえり目的の達成基準&quot; id=&quot;markdown-toc-ふりかえり目的の達成基準&quot;&gt;ふりかえり目的の達成基準&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#条件制約&quot; id=&quot;markdown-toc-条件制約&quot;&gt;条件・制約&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#個別のふりかえりミーティングをデザインする&quot; id=&quot;markdown-toc-個別のふりかえりミーティングをデザインする&quot;&gt;個別のふりかえりミーティングをデザインする&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#今回のふりかえりミーティングで目指すフェーズ&quot; id=&quot;markdown-toc-今回のふりかえりミーティングで目指すフェーズ&quot;&gt;今回のふりかえりミーティングで目指す「フェーズ」&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#今回の参加者の属性&quot; id=&quot;markdown-toc-今回の参加者の属性&quot;&gt;今回の参加者の属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#今回のふりかえり手法&quot; id=&quot;markdown-toc-今回のふりかえり手法&quot;&gt;今回のふりかえり手法&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#-発散フェーズで気をつけていること&quot; id=&quot;markdown-toc--発散フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 発散フェーズで気をつけていること&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-深堀フェーズで気をつけていること&quot; id=&quot;markdown-toc--深堀フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 深堀フェーズで気をつけていること&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#-解決フェーズで気をつけていること&quot; id=&quot;markdown-toc--解決フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 解決フェーズで気をつけていること&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ふりかえりの大枠をデザインする&quot;&gt;ふりかえりの大枠をデザインする&lt;/h3&gt;
&lt;p&gt;いきなりふりかえりミーティングについて考え出すのではなく、ふりかえりそのものの目的から考えていきます。&lt;/p&gt;

&lt;h4 id=&quot;ふりかえりの目的&quot;&gt;ふりかえりの目的&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;[誰に] [どうなってほしい]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[誰が] [どうなりたい]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;note&quot; style=&quot;margin-top:0&quot;&gt;
&lt;b&gt;サンプル&lt;/b&gt;
&lt;ul style=&quot;font-size:0.9rem&quot;&gt;
&lt;li&gt;「チームメンバーに」「開発プロセスをより良くしてほしい」&lt;/li&gt;
&lt;li&gt;「チームメンバーに」「継続的な改善を習慣づけてほしい」&lt;/li&gt;
&lt;li&gt;「マネージャーの私が」「チームメンバーが今の体制についてどう感じているか知りたい」&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ふりかえり目的の達成基準&quot;&gt;ふりかえり目的の達成基準&lt;/h4&gt;

&lt;p&gt;どんな状態になっていれば、または何ができあがっていれば、上で設定した目的が達成されたと判断できるかを明確にします。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;[状態]&lt;/strong&gt; になっている&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[最終成果物]&lt;/strong&gt; が完成している&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;note&quot; style=&quot;margin-top:0&quot;&gt;
&lt;b&gt;サンプル&lt;/b&gt;
&lt;ul style=&quot;font-size:0.9rem&quot;&gt;
&lt;li&gt;「チームが最も優先して対処すべき課題について共通認識を持っている」&lt;/li&gt;
&lt;li&gt;「開発プロセスを改善するための具体的なTODOリストが完成している」&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;h4 id=&quot;条件制約&quot;&gt;条件・制約&lt;/h4&gt;
&lt;p&gt;ふりかえりミーティングを設定するにあたって考慮しておいたほうがいいことを洗い出しておきます。以下の項目を基本セットとし、状況に応じて追加で洗い出します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ふりかえりに使える &lt;strong&gt;[時間] × [頻度]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ふりかえりの &lt;strong&gt;[参加人数]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;参加者それぞれの &lt;strong&gt;[所在地]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ふりかえりミーティングに使える &lt;strong&gt;[スペース(オンライン/オフライン)]&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ふりかえりミーティングに使える &lt;strong&gt;[ツール]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;個別のふりかえりミーティングをデザインする&quot;&gt;個別のふりかえりミーティングをデザインする&lt;/h3&gt;
&lt;h4 id=&quot;今回のふりかえりミーティングで目指すフェーズ&quot;&gt;今回のふりかえりミーティングで目指す「フェーズ」&lt;/h4&gt;

&lt;p&gt;ふりかえりミーティングで話し合われる内容は、大きく3つのフェーズに分類できます。ふりかえりの目的を達成するためには&lt;strong&gt;最終的にどのフェーズまで話し合う必要があるか&lt;/strong&gt;、そして&lt;strong&gt;今回のふりかえりミーティングではどのフェーズまで進めたいか&lt;/strong&gt;を考えます。プロジェクトを完了させるためにマイルストーンを引くようなイメージです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;フェーズ&lt;/th&gt;
      &lt;th&gt;概要&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;発散フェーズ&lt;/td&gt;
      &lt;td&gt;まずは参加者の意見やアイデアを出し切ります&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;深堀フェーズ&lt;/td&gt;
      &lt;td&gt;意見やアイデアについてディスカッションをし、理解を深めたり、取捨選択をしたり、考えを発展させたりします&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解決フェーズ&lt;/td&gt;
      &lt;td&gt;結論を出したりActionに落とし込んだりして、ディスカッションを収束させていきます&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;実際のミーティングの場では、これらのフェーズが明確に分かれていないこともあります。ディスカッションするうちに盛り上がって更に多くの意見が出て…といった具合に発散フェーズと深堀フェーズをいったりきたりすることってありますよね。それ自体は悪いことではありません。&lt;/p&gt;

&lt;p&gt;ただ、&lt;strong&gt;事前にどのフェーズまで到達したいかの目星をつけておくことで、ファシリテーションがしやすく&lt;/strong&gt;なります。&lt;br /&gt;
例えば「どんなに議論が盛り上がったとしてもラスト15分では解決フェーズに移ろう」と心の準備をしておくことで、ラスト15分までの時間で発散と深堀をいったりきたりしても焦ることなくファシリテーションできたりします。&lt;/p&gt;

&lt;p&gt;余談ですが、チームができたばかりの時期にはよく「お互いにどんなことを感じたか、どんな気持ちだったかを知り合うこと」を目的としたふりかえりをするようにしています。これは発散フェーズまでのふりかえりと言えるでしょう。&lt;/p&gt;

&lt;h4 id=&quot;今回の参加者の属性&quot;&gt;今回の参加者の属性&lt;/h4&gt;

&lt;p&gt;ふりかえりミーティングの参加者が毎回同じ顔ぶれになるとは限りません。役割ごとに集まって少人数で意見を出し合うふりかえりミーティングを開催することもあるでしょうし、ステークホルダーがゲスト参加して一緒にふりかえりミーティングをすることもあるでしょう。参加者の属性や関係性を把握することで、より参加者に合った手法を選択できます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;参加者の人数
    &lt;ul&gt;
      &lt;li&gt;人数が多すぎて全員の意見を集めきれない可能性はないか？&lt;/li&gt;
      &lt;li&gt;人数が多すぎて参加者が発言する際に心のハードルが上がる可能性がないか？&lt;/li&gt;
      &lt;li&gt;(本来参加してほしい人数に比べて)人数が少なすぎて意見が偏る可能性がないか？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;参加者の関係性
    &lt;ul&gt;
      &lt;li&gt;同じ立場・役割の人は何人いるか？&lt;/li&gt;
      &lt;li&gt;初対面の人はいるか？&lt;/li&gt;
      &lt;li&gt;評価者・被評価者の関係の人はいるか？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;それぞれの参加者の参加場所
    &lt;ul&gt;
      &lt;li&gt;一堂に会するのか？ その場合、話しやすい座席構成にできそうか？&lt;/li&gt;
      &lt;li&gt;テレビ会議でするのか？ その場合「ひとりだけテレビ会議」など発言しにくい環境になっていないか？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際には、これらの懸念点がまったくない状態をつくるのはけっこう難しいですよね…。私の属するチームは東京と福岡の多拠点なので、テレビ会議の懸念は特に起きがちです。&lt;br /&gt;
事前に払拭できずファシリテーションでカバーする場面などもあり、そのためにも事前の情報収集が大切になります。&lt;/p&gt;

&lt;h4 id=&quot;今回のふりかえり手法&quot;&gt;今回のふりかえり手法&lt;/h4&gt;
&lt;p&gt;目指すフェーズが決まり参加者の属性を把握したので、これらを踏まえていよいよ手法を考えます。手法については、事前に決めきるより&lt;strong&gt;取り得る選択肢をいくつか用意しておく&lt;/strong&gt;ことが多いです。ミーティングの状況に応じて対応できるようにするためです。&lt;/p&gt;

&lt;p&gt;手法は調べるとたくさん出てきますし、アレンジすることで無限に増えるので、ここでは手法選びで気をつけていることを挙げます。&lt;/p&gt;

&lt;h5 id=&quot;-発散フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 発散フェーズで気をつけていること&lt;/h5&gt;

&lt;p&gt;このフェーズで特に大事にしていることは&lt;strong&gt;いかに発言しやすい場を作るか&lt;/strong&gt;と、言語化が難しい&lt;strong&gt;感覚や違和感をいかに表現してもらうか&lt;/strong&gt;です。具体的には以下のようなことを考えます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Keep/Problem/Try などの意見を集める指標は、状況に応じてアレンジする
    &lt;ul&gt;
      &lt;li&gt;Problem に『反省文』ばかりが集まるときは「困難だったこと」などに置き換える、など&lt;/li&gt;
      &lt;li&gt;Try に『曖昧な行動』が集まるときは「Tryを実現するためのAction」などの指標を増やす、など&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;論理的な意見だけでなく、&lt;strong&gt;感情・感覚・違和感&lt;/strong&gt;を出してもらうような指標を使う
    &lt;ul&gt;
      &lt;li&gt;「モヤッとしたこと」「みんなに聞いてみたいこと」「ぼやき」など&lt;/li&gt;
      &lt;li&gt;状況に応じて「改善案」などの主張が強く取られる言葉を「試してみたいこと」などの柔らかめの言葉に置き換える&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;全員が意見を出しやすい仕掛けをする
    &lt;ul&gt;
      &lt;li&gt;ふりかえりミーティング中の内職が気になるときは、ペンと付箋を使うことで気持ちを切り替えてもらう&lt;/li&gt;
      &lt;li&gt;一人で考える時間とみんなで話す時間とを明確に分ける&lt;/li&gt;
      &lt;li&gt;座らずにホワイトボードの前に立って集まる&lt;/li&gt;
      &lt;li&gt;「意見を発表した後は次に意見を出してほしい人を指名する」などのルールを参加者みんなで作る&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;言語化しにくい意見を集めるときは、文字や言葉以外の方法も使う
    &lt;ul&gt;
      &lt;li&gt;モチベーションを折れ線グラフで表現する&lt;/li&gt;
      &lt;li&gt;付箋の色やドットシールの色で感情を使い分ける&lt;/li&gt;
      &lt;li&gt;納得度合いを0~3点で判断し、点数の数だけドットシールを貼る&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;全員に最低1回は意見を声に出してもらい、ふりかえりミーティングに参加するスイッチを入れてもらう&lt;/li&gt;
  &lt;li&gt;意見やアイデアを「チームの意見」と意識してもらうために、無記名にする&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;-深堀フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 深堀フェーズで気をつけていること&lt;/h5&gt;

&lt;p&gt;このフェーズでは、深堀りするトピックを&lt;strong&gt;選択し集中する&lt;/strong&gt;ことに意識を向けます。ただし、どの意見やアイデアも等しく大切な参加者の声です。&lt;strong&gt;どれかを蔑ろにすることなく&lt;/strong&gt;深堀りすることが重要であり、難しいポイントでもあります。そのために、意見の関連付けや優先順位について、合意をとることがあります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;出してもらった意見は全員が見渡せるように並べる
    &lt;ul&gt;
      &lt;li&gt;付箋で出してもらった場合は、大きな模造紙やホワイトボードに貼り付ける&lt;/li&gt;
      &lt;li&gt;意見を口頭で発表してもらう場合は、ホワイトボードなど見えるところにメモをとる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;出してもらった意見が多いときは関連性のある意見を近くにまとめて並べる
    &lt;ul&gt;
      &lt;li&gt;関係性を見出してもらい、さらに発想が広がることに期待する&lt;/li&gt;
      &lt;li&gt;関係性がバイアスになりそうなときはあえてランダムに並べることも&lt;/li&gt;
      &lt;li&gt;カテゴライズ、二次元マッピング、相関図、など情報にあったまとめ方を提案する&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;出してもらった意見すべてを1回のミーティングで深堀りしようとしない
    &lt;ul&gt;
      &lt;li&gt;ディスカッションが盛り上がると1トピック20〜40分くらいかかりがち&lt;/li&gt;
      &lt;li&gt;ミーティングの時間と目指すフェーズを考慮しながら何トピック話せそうか目星をつける&lt;/li&gt;
      &lt;li&gt;どのトピックから話すのか優先順位を決めるために投票してもらう&lt;/li&gt;
      &lt;li&gt;投票では「話すもの・話さないもの」を決めるのではなく、「話す優先順位」を決めるだけ。投票の少ない意見を切り捨てない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;-解決フェーズで気をつけていること&quot;&gt;&lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt; 解決フェーズで気をつけていること&lt;/h5&gt;

&lt;p&gt;解決フェーズで大事なことは&lt;strong&gt;実行可能性を高めること&lt;/strong&gt;に尽きます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Actionは具体的にする&lt;/li&gt;
  &lt;li&gt;Actionの期限を短めに設定する(短い期間で達成できるActionに分割する)&lt;/li&gt;
  &lt;li&gt;Actionが大きくなりすぎてしまったり抽象的になってしまう場合は、&lt;strong&gt;先行指標&lt;/strong&gt;をつくる&lt;/li&gt;
  &lt;li&gt;Actionが出すぎてしまう場合は&lt;strong&gt;上限数&lt;/strong&gt;をつくる&lt;/li&gt;
  &lt;li&gt;Actionアサイン前に、Action実行に割り当てられる&lt;strong&gt;時間を見積もっておく&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ふりかえりミーティングを定期開催している場合は、Actionの粒度を「次のミーティングまでにできること」にする(同時に開催頻度を増やし、1度のミーティング時間やActionのサイズを小さくすることも)&lt;/li&gt;
  &lt;li&gt;ふりかえりミーティングを定期開催している場合は、一度のミーティングで必ずしも「発散→深堀→解決」と一周させなくても良い&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;こうして書き出してみると、私がふりかえりをデザインするときは「発散フェーズ」を比較的強めに意識していることがわかります。思い返すと、議論がヒートアップしてしまうことよりも牽制しあって意見が出ないことのほうが多かったので、自然とそちらに意識が向いたのだと思います。&lt;/p&gt;

&lt;p&gt;当然ですが環境が変われば気をつけることは変わりますし、このデザイン方法がそのまま利用できない場面も出てくると思います。そうなったときにも揺るがない部分は何なのかを言語化していきたいと、ここまで書き出して気づきました。得に&lt;strong&gt;ふりかえりをするのに適した人間関係&lt;/strong&gt;あたりが重要になってきそうな予感です。いずれそのあたりもブログに書けるようになれたらと思います。&lt;/p&gt;

&lt;p&gt;それでは、お互い良きふりかえりライフを。&lt;/p&gt;</content><author><name></name></author><summary type="html">私の関わるいくつかのチームではよくふりかえりをします。ScrumチームがSprint毎に行う「Sprint Retrospective」であったり、フロントエンドエンジニアのチームが隔週で行う「カイゼンミーティング」であったり、呼び名や頻度や内容は様々ですが、定期的に自分たちの行動を思い返し何らかの学びを得る活動をしています。</summary></entry><entry><title type="html">ブログのCIをCircleCIからGitHub Actionsに乗り換えてみた</title><link href="https://aloerina01.github.io/blog/2020-01-09-1" rel="alternate" type="text/html" title="ブログのCIをCircleCIからGitHub Actionsに乗り換えてみた" /><published>2020-01-09T00:00:00+00:00</published><updated>2020-01-09T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2020-01-09-1">&lt;p&gt;このブログのCIをCircleCIからGitHub Actionsに移行しましたので、備忘のために作業時のメモを(補足を添えて)公開します。&lt;/p&gt;

&lt;h3 id=&quot;動機&quot;&gt;動機&lt;/h3&gt;
&lt;p&gt;GitHub ActionsをCIとして業務利用できるかどうか体感で確認したかったためです。&lt;/p&gt;

&lt;h3 id=&quot;要件&quot;&gt;要件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;developmentブランチへのpushをトリガーに&lt;a href=&quot;https://github.com/aloerina01/aloerina01.github.io/blob/development/Rakefile&quot; target=&quot;_blank&quot;&gt;Raketask&lt;/a&gt;を実行し、jekyllによって静的サイトを生成する&lt;/li&gt;
  &lt;li&gt;生成された静的サイトをmasterブランチへpushする&lt;/li&gt;
  &lt;li&gt;直近のビルド成功時のCommitと比較し、&lt;code class=&quot;highlighter-rouge&quot;&gt;/_posts/&lt;/code&gt;以下に差分がある場合はindexを生成しAlgoliaサーバにアップする&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;やったこと&quot;&gt;やったこと&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/.github/workflows&lt;/code&gt;ディレクトリを作成する(命名固定)&lt;/li&gt;
  &lt;li&gt;ディレクトリ以下にGithub Actionsのconfigファイルを作成する(命名は自由なので&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy.yml&lt;/code&gt;とする)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy.yml&lt;/code&gt;にCircleCI用のconfigファイルの内容を移植する
    &lt;ul&gt;
      &lt;li&gt;ソースをチェックアウトするために&lt;a href=&quot;https://github.com/actions/checkout&quot; target=&quot;_blank&quot;&gt;actions/checkout@v1&lt;/a&gt;を利用する&lt;/li&gt;
      &lt;li&gt;ビルド環境にrubyのインストールするために&lt;a href=&quot;https://github.com/actions/setup-ruby&quot; target=&quot;_blank&quot;&gt;actions/setup-ruby@v1&lt;/a&gt;を利用する&lt;/li&gt;
      &lt;li&gt;dependenciesをキャッシュしておくために&lt;a href=&quot;https://github.com/actions/cache&quot; target=&quot;_blank&quot;&gt;actions/cache@v1&lt;/a&gt;を利用する&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ビルドがSuccessした直近のcommit hashを特定するスクリプトを修正する(詳細後述)
    &lt;ul&gt;
      &lt;li&gt;今まではCircleCIのAPIを利用していたため&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GitHub Actionsで利用するsecretを設定する&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.circleci/config.yml&lt;/code&gt;を削除する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「ビルドがSuccessした直近のcommit」を特定する部分でハマりました。今まではCircleCIのAPIを使ってビルドログ一覧を取得したり条件で絞り込んだり簡単にできていたのですが…。Github ActionsにはそのようなAPIが見当たりませんでした。&lt;br /&gt;
Github Actionsの結果を取得する&lt;a href=&quot;https://developer.github.com/v3/checks/runs/&quot; target=&quot;_blank&quot;&gt;check runs&lt;/a&gt;や&lt;a href=&quot;https://developer.github.com/v3/checks/suites/&quot; target=&quot;_blank&quot;&gt;check suites&lt;/a&gt;、commitのステータスを取得する&lt;a href=&quot;https://developer.github.com/v3/repos/statuses/&quot; target=&quot;_blank&quot;&gt;statuses&lt;/a&gt;などのAPIはあるものの、それらからは条件に該当するcommit hashを抽出することはできず、直前のcommitと比較する方法に妥協しました。&lt;/p&gt;

&lt;p&gt;いい方法知っている方がいましたらお助けください…！&lt;/p&gt;

&lt;h3 id=&quot;使ってみた所感&quot;&gt;使ってみた所感&lt;/h3&gt;
&lt;p&gt;ビルド速度の劣化はありませんでしたので一安心です。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle install&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;したものをキャッシュする設定はCircleCI(ver2)よりも書きやすく、読みやすいと感じました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.circleci/config.yml&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;restore_cache&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle-cache-{{ checksum &quot;Gemfile.lock&quot; }}&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle-cache-&lt;/span&gt;

&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;save_cache&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle-cache-{{ checksum &quot;Gemfile.lock&quot; }}&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;vendor/bundle&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CircleCIでは「キャッシュする/キャッシュを復元する」記述をそれぞれ書いていました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.github/workflows/deploy.yml&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/cache@v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;vendor/bundle&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{ runner.os }}-gem-${{ hashFiles('**/Gemfile.lock') }}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Github Actionsでは「何をキャッシュするのか」を記述すれば良いので分かりやすく感じました。「キャッシュがない場合は〇〇する」処理も&lt;code class=&quot;highlighter-rouge&quot;&gt;if: steps.&amp;lt;step_name&amp;gt;.outputs.cache-hit != ‘true’&lt;/code&gt;と書けるので直感的でした。&lt;/p&gt;

&lt;p&gt;一方で、GitHub Actionsのログを柔軟に取得するAPIがなかったり、結果Viewに「キャッシュをクリアして再ビルドする」ボタンがなかったりと、少し込み入ったことをすると困る場面が多かったです。&lt;/p&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;CircleCIから移行することはできましたし、configファイルも比較的書きやすかったですが、かゆいところに手が届かない印象です。当面は使っていきますが、業務利用はまだ控えておこうと思います。今後に期待します！&lt;/p&gt;</content><author><name></name></author><summary type="html">このブログのCIをCircleCIからGitHub Actionsに移行しましたので、備忘のために作業時のメモを(補足を添えて)公開します。</summary></entry><entry><title type="html">ゲームをみんなでやったら自然とモブプロに入門できた話</title><link href="https://aloerina01.github.io/blog/2019-12-10-1" rel="alternate" type="text/html" title="ゲームをみんなでやったら自然とモブプロに入門できた話" /><published>2019-12-10T00:00:00+00:00</published><updated>2019-12-10T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-12-10-1">&lt;p&gt;とあるゲーム好きなチームメンバーからの一声をきっかけに、&lt;strong&gt;Factorio&lt;/strong&gt;というPCゲームをみんなでやる「モブFactorio」なる会を開催しました。命名こそ「モブ」と言っていますが、ゲーム好き4人が集まってわいわいゲームしようという軽い気持ちでの開催でした。&lt;br /&gt;
が、これが想像以上にモブの良さを実感でき、ちょうど良いモブ入門の場となったので様子をレポートします。&lt;/p&gt;

&lt;h3 id=&quot;factorioとは&quot;&gt;&lt;a href=&quot;https://store.steampowered.com/app/427520/Factorio/?l=japanese&quot; target=&quot;_blank&quot;&gt;Factorio&lt;/a&gt;とは&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Factorioは無限に広がる2D世界に自動化された工場を建設し、次第に複雑になる様々なアイテムを製造するゲームです&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;何もないだだっ広い世界で石炭を掘ったり資材を集めるところから始まり、徐々に蒸気機関やベルトコンベアなどの科学の力を使いながら効率的な工場を作っていく……というようなゲームでした(初プレイした私の目線での概要なので、間違っていたらそっと教えてください)。&lt;/p&gt;

&lt;h3 id=&quot;第1回目の様子---ゲームを楽しむと自然にモブになる&quot;&gt;第1回目の様子 - ゲームを楽しむと自然にモブになる&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-12-10-1-mob.jpg&quot; alt=&quot;モブ風景&quot; /&gt;&lt;/p&gt;

&lt;p&gt;業務後にふらっと集まり、出前をとって準備完了です。&lt;br /&gt;
参加者は「Factorioに興味はあるものの買おうとまでは思っていない」状態だったので、ハマっている人のPCを借りて皆で交代しながらやる方針に。ゲームを持っている人の家に集まって遊ぶ構図に近いですね。結果的に操作するプレイヤー1人(ドライバー)と周りでとやかく言う3人(ナビゲーター)という体制ができあがり、自然とモブのかたちが出来上がりました。&lt;/p&gt;

&lt;p&gt;モブらしくやることを意識したわけではなかったのですが、他にも自然とモブの良い部分やプラクティスが実践されていたので紹介します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ドライバーはある程度の時間で交代していた&lt;/li&gt;
  &lt;li&gt;ドライバーは操作方法や意図がわからないときに&lt;strong&gt;都度手を止めて質問していた&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ドライバーは何をつくるか・どうつくるかを&lt;strong&gt;合意をとりながら&lt;/strong&gt;進めていた&lt;/li&gt;
  &lt;li&gt;経験者は常にナビゲーターに徹していた&lt;/li&gt;
  &lt;li&gt;経験者は「説明をする部分」と「実際に操作して学んでほしい部分」を意識してナビしていた&lt;/li&gt;
  &lt;li&gt;知識のないナビゲーターは質問をすることで&lt;strong&gt;場の理解を深める&lt;/strong&gt;ことに貢献していた&lt;/li&gt;
  &lt;li&gt;モブ用PCを用意していた&lt;/li&gt;
  &lt;li&gt;ドライバー交代時に席を変えることで、スムーズに交代できていた&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;モブが終わった時点でFactorio初体験の&lt;strong&gt;メンバーの知識レベルが揃っていて&lt;/strong&gt;、次回何を作るかの方針を決めて解散する運びとなりました。みんなでゲームを楽しむために自然としていたことばかりなのですが、モブの視点で見るととても効果的な進行になっていました。実は私たちの心の中にはモブの心得が根付いているのかもしれませんね。&lt;/p&gt;

&lt;h3 id=&quot;第2回目の様子---ペアプロとの比較でわかること&quot;&gt;第2回目の様子 - ペアプロとの比較でわかること&lt;/h3&gt;

&lt;p&gt;参加者はすっかりFactorioが気に入り、第2回目は全員が購入・自身のPCにインストールしてきた状態での開催となりました。&lt;br /&gt;
早くプレイしたい気持ちが高まり、今回は4人全員で協力プレイをすることに。前回のように1人のキャラクターを交代で操作するのではなく、同じ世界に4人のキャラクターが共存し同時にプレイする形式ですね。&lt;/p&gt;

&lt;p&gt;経験者の人はプレイヤーとして参加しつつもほとんど手は動かさず、現場監督のように他3人のプレイの様子を伺ったり手助けをしたりしていました。結果的に「経験者とのペアプロ × 3組」という構図になりました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3組のペアプロによる分業の良さが見えた場面&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;「鉄を用意する人」「電柱を建てる人」といったように分業することで早く発展した&lt;/li&gt;
  &lt;li&gt;ドライバー交代がなかったため、未経験者3人は操作方法を忘れる瞬間がなかった&lt;/li&gt;
  &lt;li&gt;コツを掴んだ未経験者はひとり立ちしどんどん作業を進めていけた&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;モブプロとの比較になった場面&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互いの作業が知らず知らずのうちに進んでいて、変化に追いつけない場面があった
    &lt;ul&gt;
      &lt;li&gt;「それは作り途中のラインなので、あちらのラインを使ってください」&lt;/li&gt;
      &lt;li&gt;「あれ、ここにあった掘削機ってどこにいったんですか？」&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;全員の合意なく作られたもの・消費された資源などがあった&lt;/li&gt;
  &lt;li&gt;コツを掴んだ人とそうでない人で作業進捗に大きな差が出た&lt;/li&gt;
  &lt;li&gt;人によりこだわりポイントが違い、作り方の方針に差が出た
    &lt;ul&gt;
      &lt;li&gt;「電柱は垂直に並べたかったんだけどな…」&lt;/li&gt;
      &lt;li&gt;「その生産ラインは右に伸ばしていきたかったんだけどな…」&lt;/li&gt;
      &lt;li&gt;「機械に頼らず手で掘ることで愛情が宿るんだ…！！」&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第2回目は分業した甲斐あって「作ったものの総量」という点では前回以上に成果がありました。しかし全員で合意のとれているものや全員が仕組みを理解しているものはあまり多くありませんでした。また参加者のプレイヤーとしての成熟度に差が出始めました。&lt;/p&gt;

&lt;p&gt;これは単なるゲーム会なので、成果の有無に関わらず全員が楽しめたので第2回目も大成功と言えます。ただ、ちょっとだけ業務的な視点で見てみると、&lt;strong&gt;合意・レビュー・情報共有の不足&lt;/strong&gt;が確かにあり、これを埋めようと思うとそれなりの時間を使うことになるでしょう。これはまさしくモブをすることで得られるメリットの裏返しで、モブの良さを逆説的に実感できる会となりました。&lt;/p&gt;

&lt;h3 id=&quot;おわりに&quot;&gt;おわりに&lt;/h3&gt;

&lt;p&gt;あくまでゲーム会なので楽しむことが最優先で、実際の業務とは意識や行動が違う部分もあったと思いますが、それでもモブの良さを体感するという観点でも価値のある場になったと感じています。&lt;/p&gt;

&lt;p&gt;モブに興味がある方や始めてみたいと感じている方は、モブについてもう少し体系的に紹介している&lt;a href=&quot;/blog/2019-03-12-1&quot;&gt;「モブプログラミング・ベストプラクティス」読んだのでモブプロの魅力と始め方をまとめる&lt;/a&gt;の記事も併せてご参考いただければと思います。ハッピーモビング！&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;* * *&lt;/p&gt;

&lt;p&gt;ちなみに記事内写真のマスクに使ったイラストはLINE絵文字の&lt;a href=&quot;https://store.line.me/emojishop/product/5cbbbe67040ab16170b524d4/ja&quot; target=&quot;_blank&quot;&gt;ちゃんくろ絵文字&lt;/a&gt;です。我が家のねこがモデルです、よければご購入ください。&lt;/p&gt;</content><author><name></name></author><summary type="html">とあるゲーム好きなチームメンバーからの一声をきっかけに、FactorioというPCゲームをみんなでやる「モブFactorio」なる会を開催しました。命名こそ「モブ」と言っていますが、ゲーム好き4人が集まってわいわいゲームしようという軽い気持ちでの開催でした。 が、これが想像以上にモブの良さを実感でき、ちょうど良いモブ入門の場となったので様子をレポートします。</summary></entry><entry><title type="html">「チームがうまく失敗し学ぶために私にできること」の補足と裏話</title><link href="https://aloerina01.github.io/blog/2019-11-27-1" rel="alternate" type="text/html" title="「チームがうまく失敗し学ぶために私にできること」の補足と裏話" /><published>2019-11-27T00:00:00+00:00</published><updated>2019-11-27T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-11-27-1">&lt;p&gt;2019年11月25日、&lt;a href=&quot;https://line.connpass.com/event/154447/&quot; target=&quot;_blank&quot;&gt;LINE Developer Meetup #58&lt;/a&gt; にて登壇の機会をもらったので、「チームがうまく失敗し学ぶために私にできること」というタイトルで発表してきました。&lt;/p&gt;

&lt;script async=&quot;&quot; class=&quot;speakerdeck-embed&quot; data-id=&quot;8b3ee51403284b37956b96592f1be8c9&quot; data-ratio=&quot;1.33333333333333&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;慣れない登壇で上手く伝えきれたか不安なので、言い訳がましく補足をしていこうと思います。&lt;/p&gt;

&lt;h3 id=&quot;補足&quot;&gt;補足&lt;/h3&gt;

&lt;p&gt;今回の話は、&lt;strong&gt;チームにより安全かつ効果的に失敗から学んでもらいたい・もらえる環境をつくっていきたい&lt;/strong&gt;という私の個人的な思いの元、それを実現していくためにどんなことを考えているかを言語化したものでした。&lt;/p&gt;

&lt;p&gt;ですのでチームメンバーと合意をとって取り組んだことというよりは、私がどういう思いを持っていて、どういう&lt;strong&gt;思考プロセス&lt;/strong&gt;を経てどういう行動を起こしているか、というやや自分語り的な内容となっています。&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;* * *&lt;/p&gt;

&lt;p&gt;発表の中で失敗の分析方法について触れていますが、これは&lt;strong&gt;私が日常的もしくは定期的にしている&lt;/strong&gt;方法になります。チームが出来上がったばかりの頃は特に丁寧にやっていたため付箋やホワイトボードの写真が残っていましたが、今ではノートの端切れに殴り書いたりと雑に(短時間で素早く)やっています。&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;* * *&lt;/p&gt;

&lt;p&gt;失敗と向き合うために心に留めていることとして「失敗は実績解除だ」と締めくくっていますが、「実績解除」という言葉は人によっては馴染みのないものだったかもしれません。発表の仕方を工夫すべきだったなとまさしく失敗から学んだ点でもあります。&lt;br /&gt;
ここで伝えたかったことは「学ぶための貴重な機会である&lt;strong&gt;尊い失敗体験&lt;/strong&gt;をネガティブな言葉で表現したくない」ということでした。&lt;/p&gt;

&lt;h3 id=&quot;裏話&quot;&gt;裏話&lt;/h3&gt;

&lt;p&gt;登壇が苦手なので日頃の発信はブログで行っているのですが、せっかく登壇の機会をもらえたので&lt;strong&gt;文字だけでは伝えにくいことを言葉と図で伝える&lt;/strong&gt;ことにこだわりたいと思って臨みました。その効果が如何ほどだったかは測れていないので、聞いていただいた方からのフィードバックを楽しみにしています。&lt;/p&gt;

&lt;p&gt;ちなみに私が登壇資料をつくるときは&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;伝えたいことを箇条書きでリストアップする(ここでほぼ内容を固めます)&lt;/li&gt;
  &lt;li&gt;声に出して何度も話しながら流れを組み上げる&lt;/li&gt;
  &lt;li&gt;話しながら思い浮かぶ図を手書きで書き起こす(ここでスライドのおおよその枚数が見えてきます)&lt;/li&gt;
  &lt;li&gt;Keynoteでスライドをつくる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という流れになることが多いです。&lt;/p&gt;

&lt;h3 id=&quot;グラレコ&quot;&gt;グラレコ&lt;/h3&gt;

&lt;p&gt;最近Meetupの参加メモをiPadで手書きで取るようにしているので、おまけとして公開しておきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-11-27-1-grareco_1.jpg&quot; alt=&quot;grareco_1&quot; loading=&quot;lazy&quot; /&gt;
「LINEリサーチ開発におけるScrumのこれまでとこれから」 by 門谷さん&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-11-27-1-grareco_2.jpg&quot; alt=&quot;grareco_2&quot; loading=&quot;lazy&quot; /&gt;
「仲間の多様な価値観を尊重しつつ、チームとして成果を出すための戦略」 by 米原さん&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;グラレコ(っぽいもの)を手早くそれっぽくつくるコツは「背景色をつけて白文字にすること」と「矩形で情報を束ねること」だと勝手に思っていますが、もっといい方法あれば是非アドバイスいただけると嬉しいです！&lt;/p&gt;</content><author><name></name></author><summary type="html">2019年11月25日、LINE Developer Meetup #58 にて登壇の機会をもらったので、「チームがうまく失敗し学ぶために私にできること」というタイトルで発表してきました。</summary></entry><entry><title type="html">チームが上手く失敗するためにマネージャーの私にできること</title><link href="https://aloerina01.github.io/blog/2019-10-24-1" rel="alternate" type="text/html" title="チームが上手く失敗するためにマネージャーの私にできること" /><published>2019-10-24T00:00:00+00:00</published><updated>2019-10-24T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-10-24-1">&lt;p&gt;私は現在、フロントエンドエンジニア5人のチームのマネージャーと、職種混合8人チームのスクラムマスターを担当しています。どちらの役割においても、&lt;strong&gt;チームがより自律的で効果的になること&lt;/strong&gt;を意識して関わっています。&lt;/p&gt;

&lt;p&gt;ところで、&lt;strong&gt;心配性な&lt;/strong&gt;私はチームが将来出くわすであろう失敗やトラブルを予測して先回りで対策しようとする傾向にありました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;この案件は〇〇さんが担当したら苦戦するかもしれないから、△△さんにヘルプはいる準備をしておいてもらおう&lt;/li&gt;
  &lt;li&gt;ふりかえりの開催は面倒臭がられるだろうから、自分が開催する役目をしよう&lt;/li&gt;
  &lt;li&gt;この人とあの人は相性が悪くて上手く進捗しないだろうから、別々のチームにしよう&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実例ではないのですが、例えばこんな感じです。&lt;br /&gt;
こういったリスクヘッジや環境整備などは、本の言葉を借りるなら「未来や人間関係の不確実性を減らすこと」と言えそうで、マネージャーの仕事であるように感じていました。&lt;/p&gt;

&lt;p&gt;一方で、&lt;strong&gt;その不確実性は本当に解消すべきものだったのか？ チームが失敗して学ぶチャンスだったのではないか？&lt;/strong&gt; という不安も感じるようになりました…。この不安を通じて考え方が少し変わったと思うので、自分語りしながら整理してみようと思います。&lt;/p&gt;

&lt;h3 id=&quot;失敗を恐れているのは誰か&quot;&gt;失敗を恐れているのは誰か&lt;/h3&gt;

&lt;p&gt;「このままだと上手くいかないかもしれない、問題が起きるかもしれない」という思いは誰かの頭の中で生まれます。それはチームメンバー、マネージャー、もしくは外部の人ということも……。もちろん人により見えてる景色が違うので懸念や不安も違うはずですが、&lt;strong&gt;誰かの目線では解決の余地のあること、大した問題でもないこと&lt;/strong&gt;を、心配性の私は勝手に不安がっていた可能性もあるわけです。&lt;/p&gt;

&lt;p&gt;この解決策は言うだけなら簡単で、&lt;strong&gt;チームで会話して懸念や不安を共有すれば良い&lt;/strong&gt;ですよね。ただ実行するのは難しく……日頃から胸の内をオープンにし合える関係性・コミュニケーションの場を作っておくことが大事だと痛感させられました。&lt;/p&gt;

&lt;h3 id=&quot;それは失敗じゃない実績解除だ&quot;&gt;それは失敗じゃない、実績解除だ&lt;/h3&gt;

&lt;p&gt;失敗を避けていた自分の振る舞いを変えるキッカケとなった発想は、「&lt;strong&gt;その失敗は本当にしてはいけない失敗なのか&lt;/strong&gt;」でした。&lt;/p&gt;

&lt;p&gt;私は寝る前に(ひどいときは朝起きてからも)失敗したことを思い返して何がどうダメだったのかを延々考える癖があります。この積み重ねでしか前進できない自覚もあって、私にとって&lt;strong&gt;失敗は必要な要素&lt;/strong&gt;だと認識するようになりました。ということは、もしかしたらチームにとっても失敗する経験は必要なのかもしれません。&lt;/p&gt;

&lt;p&gt;そう思ってチームメンバーをかえりみると、各々から「同じ失敗を繰り返さないようにしよう」という意志が感じ取れました。ちゃんと失敗を見つめ返して乗り越えて糧にしようという気概がありました。そうなるとあとは私がチームを信じて、チームに失敗してもらうだけですよね。&lt;/p&gt;

&lt;p&gt;そんな尊い行為を失敗なんてネガティブな言葉では呼びたくなくて、&lt;strong&gt;実績解除&lt;/strong&gt;と呼ぶようにしています。&lt;/p&gt;

&lt;h3 id=&quot;実績解除のあとの展開を予測する&quot;&gt;実績解除のあとの展開を予測する&lt;/h3&gt;

&lt;p&gt;チームが実績解除の積み重ねで前進するようになったとはいえ、起きてはいけない問題もあります。そしてそれを阻止したり回避したりする責任はマネージャーにあるでしょう。&lt;br /&gt;
阻止することは難しくないと思っていました。「失敗を予測して阻止する」ことができるなら「失敗の影響範囲や重要度を予測して阻止する」こともできると踏んだわけです。&lt;/p&gt;

&lt;p&gt;しかしいざ取り組んでみたら、&lt;strong&gt;どこまで挑戦してもらって、どこを未然に防ぐか&lt;/strong&gt;のバランスを常にとり続ける難しさが待っていました。特に秀でたところのない私にとって「バランス感覚が良いこと」は生存戦略のつもりだったのですが、このバランス取りはすごく難しくて、今でも悩み続けています。&lt;/p&gt;

&lt;h3 id=&quot;パターンは頼もしくて脆い&quot;&gt;パターンは頼もしくて、脆い&lt;/h3&gt;

&lt;p&gt;チームが実績解除に挑むのと時を同じくして、私は「チームにとって最適な実績解除をどうやって経験してもらうか」の課題に挑戦し続けることになります。どれほどの難易度の経験をどのタイミングでしてもらうのが良いか、その経験のチャンスはどこに転がっているか…と日々悩み臨んでいるのですが、当然のように毎回失敗をします。&lt;/p&gt;

&lt;p&gt;失敗しては別のアプローチをしてまた失敗して…を延々繰り返していれば選択肢も増えるし、うまくいった選択肢はパターンとして自分の中に定着したりもします。&lt;strong&gt;パターンを覚えて強くなったと錯覚した&lt;/strong&gt;日もありました。&lt;br /&gt;
少し考えれば気づけたことですが、全く同じ人間はいないので同じパターンが通用することなんてないわけです。パターンを覚えたからといってレベルアップしたわけではないのです。&lt;/p&gt;

&lt;p&gt;大事なのは、パターンの使い回しではなく応用です。応用に必要なものは&lt;strong&gt;具体策より方針&lt;/strong&gt;です。つまり、上手くいったアプローチをパターンとして蓄積させる過程では、個別具体的な部分を削ぎ落とし抽象化させていくことも必要なのでした。なんとか言語化までできたパターンの例を挙げてみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;問題が起き得ることに気づいても何もせず、あえて問題を起こさせる。&lt;strong&gt;一度経験してしまえば次回は防げるであろう事例&lt;/strong&gt;で使う&lt;/li&gt;
  &lt;li&gt;特定の問題に目を向けるよう、または集中するよう促す。&lt;strong&gt;解決策を試行錯誤する過程で実績解除できるであろう事例&lt;/strong&gt;で使う&lt;/li&gt;
  &lt;li&gt;自分が取り組む問題に協力してもらえないか聞く。&lt;strong&gt;マネージャーが実績解除する姿を追体験させたい事例&lt;/strong&gt;で使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いざ言葉にしてみるとパターンと呼ぶには見すぼらしい感じがしますね。それでもこれらを呼吸するように引き出せる状態になれば、一人ひとりの反応を見ることに集中できるようになり、コミュニケーションを洗練させられる気がします。そうなることを目指して、今しばらくはこの脆いパターンを蓄積させていこうと思う次第です。&lt;/p&gt;

&lt;h3 id=&quot;本音&quot;&gt;本音&lt;/h3&gt;

&lt;p&gt;自分の失敗をふりかえることを通じて失敗の必要性を実感し、チームが実績解除して前進していくことを意識するようになった話でした。&lt;/p&gt;

&lt;p&gt;これが今自分にできることだと信じていますが、正直なところ全然自信はなくて、チームが前進しているかどうかも不安です。もっと別の視点や要素があるよ！という方はぜひ&lt;a href=&quot;https://twitter.com/aloerina_&quot; target=&quot;_blank&quot;&gt;@aloerina_&lt;/a&gt;まで一言アドバイスをよろしくお願いします。&lt;/p&gt;</content><author><name></name></author><summary type="html">私は現在、フロントエンドエンジニア5人のチームのマネージャーと、職種混合8人チームのスクラムマスターを担当しています。どちらの役割においても、チームがより自律的で効果的になることを意識して関わっています。</summary></entry><entry><title type="html">VuexのStore設計のTips - 薄いGetter</title><link href="https://aloerina01.github.io/blog/2019-09-25-1" rel="alternate" type="text/html" title="VuexのStore設計のTips - 薄いGetter" /><published>2019-09-25T00:00:00+00:00</published><updated>2019-09-25T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-09-25-1">&lt;p&gt;Vue + Vuexで中〜大規模なアプリケーションの開発をするとき、どんな設計にするか未だによく悩みます。試してみては捨ててを繰り返していて、そろそろ自分の中でベターなパターンを固めたいと思いつつも固まらず、気づけば数年経ちました。&lt;/p&gt;

&lt;p&gt;そういった前提を踏まえつつではありますが、&lt;strong&gt;現時点&lt;/strong&gt;で設計時に意識していることをTips的に少しずつまとめてみようと思います。今回はVuexのGetterに関するお話です。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#getterの役割を見直す&quot; id=&quot;markdown-toc-getterの役割を見直す&quot;&gt;Getterの役割を見直す&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#副作用のないクエリとして実装する&quot; id=&quot;markdown-toc-副作用のないクエリとして実装する&quot;&gt;副作用のないクエリとして実装する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#プロパティアクセスとメソッドアクセスを区別して命名する&quot; id=&quot;markdown-toc-プロパティアクセスとメソッドアクセスを区別して命名する&quot;&gt;プロパティアクセスとメソッドアクセスを区別して命名する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#プリミティブでシンプルなクエリとして実装する&quot; id=&quot;markdown-toc-プリミティブでシンプルなクエリとして実装する&quot;&gt;プリミティブでシンプルなクエリとして実装する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#表示用の加工処理はcomponentに実装する&quot; id=&quot;markdown-toc-表示用の加工処理はcomponentに実装する&quot;&gt;表示用の加工処理はComponentに実装する&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#例外1-加工された値の賞味期限が長い場合&quot; id=&quot;markdown-toc-例外1-加工された値の賞味期限が長い場合&quot;&gt;例外1. 加工された値の賞味期限が長い場合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#例外2-加工処理が複数componentで繰り返される場合&quot; id=&quot;markdown-toc-例外2-加工処理が複数componentで繰り返される場合&quot;&gt;例外2. 加工処理が複数Componentで繰り返される場合&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#おわりに&quot; id=&quot;markdown-toc-おわりに&quot;&gt;おわりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;getterの役割を見直す&quot;&gt;Getterの役割を見直す&lt;/h3&gt;

&lt;p&gt;VuexはFluxアーキテクチャを参考にしており、他のFlux系フレームワークと同様にStoreではStateを保持し、Stateが更新されるとそれをViewに通知します。&lt;br /&gt;
このときVuexのStoreは&lt;strong&gt;Getterを通じてStateの一部を切り出して&lt;/strong&gt;Viewに渡すことができます。よくあるFlux系Storeは&lt;code class=&quot;highlighter-rouge&quot;&gt;getState&lt;/code&gt;関数などでStateオブジェクトを丸々渡すケースが多いので対照的ですよね。&lt;/p&gt;

&lt;p&gt;この性質に着目すると、VuexのStoreは外部に対して&lt;strong&gt;読み込み系のGetter&lt;/strong&gt;と&lt;strong&gt;書き込み系のAction(とMutation)&lt;/strong&gt;の仕組みを備えていると考えられます。&lt;/p&gt;

&lt;h3 id=&quot;副作用のないクエリとして実装する&quot;&gt;副作用のないクエリとして実装する&lt;/h3&gt;

&lt;p&gt;書き込み系と読み込み系の分離といえば、CQS (Command-Query Separation) や CQRS (Command and Query Responsibility Segregation) などの設計パターンが思い当たります。ここではよりシンプルなCQSを参考に考えます。&lt;/p&gt;

&lt;p&gt;CQSの基本的な考え方は、オブジェクトが持つメソッドを大きく2つのカテゴリに分類するというものです。1つは副作用が起き得る書き込み系の処理の&lt;strong&gt;Command&lt;/strong&gt;、もう一つは副作用のない読み込み系の処理の&lt;strong&gt;Query&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;Getterもこれにならって副作用が起きないように実装します。&lt;br /&gt;
これだけ見ると当たり前なのですが、「〇〇を表示したときにイベントをemitする」「〇〇を表示したときにフラグを立てる」といった実装をするとき、〇〇を返すGetterの中でemitしたりフラグを立てたりするのもNGなので要注意です。代わりに副作用の起きる処理はMutationやActionに寄せます。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// NG&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;articles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isShown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;articles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// OK&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;articles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;articles&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mutations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;shown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isShown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&quot;プロパティアクセスとメソッドアクセスを区別して命名する&quot;&gt;プロパティアクセスとメソッドアクセスを区別して命名する&lt;/h3&gt;

&lt;p&gt;これは完全に好みの話なので蛇足ですが、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;プロパティアクセスのGetterは返すデータを表す名詞で命名する&lt;/li&gt;
  &lt;li&gt;メソッドアクセスのGetterは&lt;code class=&quot;highlighter-rouge&quot;&gt;find{名詞}&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;find{名詞}By{条件}&lt;/code&gt;と命名し、引数に条件をとる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というマイルールで実装しています。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// プロパティアクセスの場合は名詞で命名する&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// メソッドアクセスの場合は動詞(find)で命名する&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;findBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 条件別にGetterを用意する場合は 動詞 + by条件 と命名する&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;findBooksByAuthor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;findBookByISBN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ISBN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ISBN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ISBN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ちなみに過去に&lt;code class=&quot;highlighter-rouge&quot;&gt;getHoge&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;filterHoge&lt;/code&gt;など動詞を使い分けていたこともあったのですが、開発者によって使い分けルールが曖昧だったので最近はすべて&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;に統一しています。&lt;/p&gt;

&lt;h3 id=&quot;プリミティブでシンプルなクエリとして実装する&quot;&gt;プリミティブでシンプルなクエリとして実装する&lt;/h3&gt;

&lt;p&gt;Getterで取り出した値をどう使うかは使う側に依存するので、値を加工したりせずState(の一部)をそのまま返すだけのシンプルなGetterを実装するように意識します。&lt;br /&gt;
これを守るためにも上述の命名ルールが役立っていて、データをまるごと返す場合はデータ名を使った名詞で命名し、データの集合から一部を検索して返す場合はfindで命名すると限定することで、自然とシンプルでプリミティブな役割を持つクエリとして実装することができます。&lt;/p&gt;

&lt;p&gt;では、データを加工して渡したい場合はどうするのが良いでしょうか？&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;firstName&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;lastName&lt;/code&gt;を組み合わせて一つの&lt;code class=&quot;highlighter-rouge&quot;&gt;fullName&lt;/code&gt;文字列として扱う例のように、Stateの値は書き換えないまま一時的に加工された値を生成する場面はよくあると思います。この加工処理をどこで担うのが良いでしょうか？&lt;/p&gt;

&lt;h3 id=&quot;表示用の加工処理はcomponentに実装する&quot;&gt;表示用の加工処理はComponentに実装する&lt;/h3&gt;

&lt;p&gt;Stateを加工したり組み合わせたりして表示に適した値に変換する処理は、原則Component側で担うようにしています。StoreからGetterで取得した値をComputedなどで変換して表示する……という実装方法です。&lt;br /&gt;
データモデルやアプリケーションの状態といったコアな情報のみをStoreで持ち、Viewの状態をComponentで持つようにすることで、&lt;strong&gt;Viewの仕様変更に耐えやすくする&lt;/strong&gt;狙いです。&lt;/p&gt;

&lt;p&gt;ちなみにFluxではViewの状態もStoreに持たせる傾向にありますが、Vue + VuexアプリケーションをMVVMと捉えるならVueComponentはVMに相当し、表示のための加工とその結果の保持を担うべき場所とみなすことができます。捉え方によって解釈も変わってきそうですが、私は&lt;strong&gt;StoreのGetterをViewに依存させないこと(Viewの仕様に引きずられないこと)&lt;/strong&gt;を重視したいので、MVVM寄りの捉え方をすることが多いです。&lt;/p&gt;

&lt;p&gt;とはいえこれはあくまで原則。&lt;br /&gt;
例外的な場面での対処法も考慮しておく必要があります。&lt;/p&gt;

&lt;h4 id=&quot;例外1-加工された値の賞味期限が長い場合&quot;&gt;例外1. 加工された値の賞味期限が長い場合&lt;/h4&gt;

&lt;p&gt;1つ目の例外は、加工された値の賞味期限がComponentのライフサイクルより長い場合です。複数のComponentで使われる場合もこれに該当します。&lt;/p&gt;

&lt;p&gt;Componentが破棄された後も値を保持し続けなければいけない場合は、当然ですがStoreで保持しなければなりません。Storeで保持する以外にもClosureで実装したりSingletonで実装したりと値の保持方法はありますが、状態を持つ仕組みが複数存在すると複雑さが増すので注意が必要です。&lt;/p&gt;

&lt;h4 id=&quot;例外2-加工処理が複数componentで繰り返される場合&quot;&gt;例外2. 加工処理が複数Componentで繰り返される場合&lt;/h4&gt;

&lt;p&gt;そこそこの規模・複雑さのアプリケーションを開発していると、「Module分けされたAとBのStoreからStateを取ってきて組み合わせに応じた表示をする」なんて場面が出てくるかもしれません。また「複雑な条件分岐を経てどのように加工されるかが決まる」といった場面もあり得るでしょう。&lt;br /&gt;
このように加工処理が複雑で、なおかつ複数のComponentで必要な場合は、加工処理を関数として外出しする選択肢がとれます。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 外出しした加工処理の実装&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stateA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;stateB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 引数をもとに加工された値を生成して返す&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// component側&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;convert&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./convert&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;computed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;displayValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 外出しされた加工処理を利用する&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stateA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stateB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例えば「Listを表示する画面にて、ユーザーがソート方法を切り替えるとインタラクティブにItemの並び順が変わる」といったような場面では、数種類のsort関数を外出ししておくことができそうですよね。&lt;/p&gt;

&lt;h3 id=&quot;おわりに&quot;&gt;おわりに&lt;/h3&gt;
&lt;p&gt;設計に関することは日々うにゃうにゃ考えているものの、当たり前の内容であったり状況次第で何とでも解釈できる内容であったりして、書き残すことにあまり意味を感じていませんでした。が、いざ設計しようと思ったときに考慮すべき観点や選択肢としてパッと浮かんでくるものは、やはり言語化して腹落ちしたものなんですよね。&lt;/p&gt;

&lt;p&gt;また、言語化することでフィードバックをもらえたり議論のきっかけになったりする良さもあると思うので、1ヶ月後には意見が変わっているかもしれませんがこうして書き残す試みを今後もしていこうと思います。&lt;/p&gt;</content><author><name></name></author><summary type="html">Vue + Vuexで中〜大規模なアプリケーションの開発をするとき、どんな設計にするか未だによく悩みます。試してみては捨ててを繰り返していて、そろそろ自分の中でベターなパターンを固めたいと思いつつも固まらず、気づけば数年経ちました。</summary></entry><entry><title type="html">みんなのモブプロの疑問に答えてみた</title><link href="https://aloerina01.github.io/blog/2019-07-25-1" rel="alternate" type="text/html" title="みんなのモブプロの疑問に答えてみた" /><published>2019-07-25T00:00:00+00:00</published><updated>2019-07-25T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-07-25-1">&lt;p&gt;先日モブプロMeetupが開催されました。モブプロに関する知見や悩みが共有されて、モブプロの楽しさや難しさを再認識できる良い時間でした。&lt;/p&gt;

&lt;p&gt;ところで、このイベントでは参加者から質問を集める機会があったのですが、どれも身近に感じる質問だったので、自分の思考整理のために私の目線で答えて見ようと思います。現場の実例共有も兼ねて。&lt;/p&gt;

&lt;h3 id=&quot;有識者が参加していない場合コードレビューをどうしていますか&quot;&gt;有識者が参加していない場合、コードレビューをどうしていますか？&lt;/h3&gt;

&lt;p&gt;参加者に合わせてモブプロのゴールを調整しています。&lt;br /&gt;
私のチームのモブプロでは有識者が参加しているケースが多いので、「GitHub上でのコードレビューなく即Mergeできる状態」を目指すことが多いです。とはいえ欠席が重なり有識者がいない場合もあるので、その際は「参加者の中では合意の取れた状態」を目指し、あとで有識者にレビューしてもらったりしています。急ぎでない場合は別の案件に取り組む、できる部分だけやる、といった選択をとることもあります。&lt;/p&gt;

&lt;h3 id=&quot;暴走しがちな人がいる場合にどう対処しますか&quot;&gt;暴走しがちな人がいる場合にどう対処しますか？&lt;/h3&gt;

&lt;p&gt;私のチームでは、ナビゲーターの一人だけが発言しまくるといった暴走よりも、ドライバーが一人でコードを書き進めちゃう暴走のほうが起きがちです。私もやりがちなのですが、コードを書いているうちに脳内で先読みが捗ってしまうんですよね。そして場を置き去りにしてひとりで書き進めちゃうんですよね…。&lt;/p&gt;

&lt;p&gt;このとき「ちょっと待って」「声に出してから書いてみて」とブレーキをかけるのもナビゲーターの役目だと思っています。ナビゲーターの一人だけが発言している場合に「〇〇さんはどう思う？」と別の人に話を振ることも然り。モブの進め方を改善できるのはモブの参加者自身だと思うのです。&lt;/p&gt;

&lt;h3 id=&quot;モブプロを定着させるために特別な取り組みをしましたか&quot;&gt;モブプロを定着させるために特別な取り組みをしましたか？&lt;/h3&gt;

&lt;p&gt;私がチームにモブを導入したときは、&lt;strong&gt;みんなでひとつの仕事をすることを「モブ」と呼び&lt;/strong&gt;、モブは身近なものであるという認識を浸透させることを意識しました。具体的には&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;もともと開催していたコードレビュー会を「モブレビュー」と呼ぶようにした&lt;/li&gt;
  &lt;li&gt;Slackにモブに関する情報共有のChannelを立てて情報発信した&lt;/li&gt;
  &lt;li&gt;モブプロの時間を確保しトライアルした&lt;/li&gt;
  &lt;li&gt;チームメンバーが議論している場に顔出し「モブしてるね！」と声掛けて回った&lt;/li&gt;
  &lt;li&gt;実装に関する相談を受けたときに「モブでやっつけてみる？」と提案した&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった感じです。今では自然と複数人で集まって問題解決する場面が増えてきたので、チームにモブという選択肢が浸透してきたように感じます。&lt;/p&gt;

&lt;p&gt;きちんとドライバーとナビゲーターを決めインターバルを回すモブプロの形式にはなっていないこともありますが、&lt;strong&gt;モブの目的に適っていれば形式にはこだわらないようにしています&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;モブプロの目的をどう設定していますか&quot;&gt;モブプロの目的をどう設定していますか？&lt;/h3&gt;

&lt;p&gt;端的にいうと「&lt;strong&gt;フロー効率をよくすること&lt;/strong&gt;」を目的にしていて、説明するときはフロー効率の改善によって得られる作用に焦点を当てて話したりしています。モブの目的にについては『&lt;a href=&quot;https://aloerina01.github.io/blog/2019-03-12-1#%E3%81%AA%E3%81%9C%E3%83%A2%E3%83%96%E3%83%97%E3%83%AD%E3%82%92%E3%81%99%E3%82%8B%E3%81%AE&quot;&gt;「モブプログラミング・ベストプラクティス」読んだのでモブプロの魅力と始め方をまとめる&lt;/a&gt;』もあわせてどうぞ。&lt;/p&gt;

&lt;h3 id=&quot;非エンジニアにモブプロのメリットをどう説明しますか&quot;&gt;非エンジニアにモブプロのメリットをどう説明しますか？&lt;/h3&gt;

&lt;p&gt;幸運にも開発プロセスについて裁量を与えてもらえる環境なので、「モブプロをやることを許可してもらうための説得」といった難易度の高い説明を経験したことがありません。&lt;/p&gt;

&lt;p&gt;ですがプランナーなどの非エンジニアにモブプロの手法を紹介したときは、エンジニアに伝えるときと同様にリソース効率とフロー効率の違いをとっかかりとし、レビュー待ち時間などによりリードタイムがかかった体験談などを交え、モブプロという手段を選択する理由を伝えました。また、&lt;strong&gt;実際にモブプロに参加してもらったり&lt;/strong&gt;様子を撮影して見せることでその場の雰囲気を知ってもらい、「自分たちも試してみようか」と感じてもらうことを目指して説明しました。&lt;/p&gt;

&lt;p&gt;ちなみに、ここでも「モブプロ」ではなく「モブ」という言葉を意識的に使うようにしています。モブプロの方法論には言及せず、モブの身近さを実感してもらうことでメリットを想像しやすい状態をつくることを意識しています。&lt;/p&gt;

&lt;h3 id=&quot;どうしてもモブプロをしたくない人がいる場合どうしますか&quot;&gt;どうしてもモブプロをしたくない人がいる場合どうしますか？&lt;/h3&gt;

&lt;p&gt;モブプロあるいはモブは&lt;strong&gt;手段のひとつ&lt;/strong&gt;です。ですので、やりたくない人がいるのであれば強制する必要はないはずです。&lt;/p&gt;

&lt;p&gt;ただ、モブプロをしたくないと感じる背景を知ることができれば、そこに何かしらの&lt;strong&gt;改善のヒント&lt;/strong&gt;があるように感じます。&lt;br /&gt;
やったことないけれどやりたくないと主張する人がいる場合は、モブ以前に「何か案が出たらとりあえず試してみる」というマインドをチームに浸透させることが必要かもしれません。&lt;br /&gt;
逆に過去にモブプロを経験した上でやりたくないと主張する人がいる場合は、モブのメリットを実感できなかったのかもしれません。どんな点がまずかったのかを聞き、今の自分たちのモブが同じ状態ではないかを見つめ直し、問題ないようであればその旨を伝えてみると良いかもしれません。&lt;/p&gt;

&lt;p&gt;いずれにせよ、やりたくない人がいるということは改善のきっかけを得るチャンスです！&lt;/p&gt;

&lt;h3 id=&quot;モブプロに合う内容合わない内容はありますか&quot;&gt;モブプロに合う内容・合わない内容はありますか？&lt;/h3&gt;

&lt;p&gt;設計やリファクタリングなど、&lt;strong&gt;人によって結果や過程に差が出やすいものは向いている&lt;/strong&gt;と感じます。また、暗黙のテクニックがあるような難解なデバッグや、環境による差が起きやすい環境構築なども実践してみて好感でした。&lt;br /&gt;
一方、修正方法が誰の目からも明らかな不具合修正や、誰がやっても過程・結果が変わらない単純作業などは向かないと思っています。&lt;/p&gt;

&lt;h3 id=&quot;モブプロに最適な人数は何人ですか&quot;&gt;モブプロに最適な人数は何人ですか？&lt;/h3&gt;

&lt;p&gt;小規模で全員が「ちゃんと」参加できる目安は4〜6人くらいかな、というのが体感です。『モブプログラミング・ベストプラクティス』には3〜4人がちょうど良いと書かれていましたし、私の現場では9人くらいでうまくできたと感じるケースもありましたので、あくまで目安です。ただ始めたばかりの頃は少なすぎても多すぎても難しく、4〜6人が安定しやすかった印象です。&lt;/p&gt;

&lt;h3 id=&quot;ドライバーは何分交代でやっていますか&quot;&gt;ドライバーは何分交代でやっていますか？&lt;/h3&gt;

&lt;p&gt;その時々によりますが、15分〜30分交代が多いです。&lt;br /&gt;
何分のインターバルにしても、最後の1分は&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ドライバーがgit commitする&lt;/li&gt;
  &lt;li&gt;次のドライバーがgit pullする&lt;/li&gt;
  &lt;li&gt;次のドライバーが書き始められるよう準備する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;にあてています。&lt;/p&gt;

&lt;h3 id=&quot;人前でコードを書くのは緊張しませんか&quot;&gt;人前でコードを書くのは緊張しませんか？&lt;/h3&gt;

&lt;p&gt;私も人前でコードを書くときは緊張しがちですが、モブプロではあまり緊張しません。&lt;br /&gt;
私の場合「考えている過程」や「未完成なコード」を見られることで能力が低いと感じ取られてしまわないか……という不安があり緊張してしまう傾向にあります。ですがドライバーは&lt;strong&gt;ナビゲーターの言うとおりに書く&lt;/strong&gt;ことがほとんどなので、みんなの意見を反映するタイピスト(兼 質問して議論を掘り下げるファシリテーター)のような感覚で臨んでいます。ちょっとした気持ちの違いですが、これでけっこう緊張をほぐせています。&lt;/p&gt;

&lt;h3 id=&quot;おわりに&quot;&gt;おわりに&lt;/h3&gt;

&lt;p&gt;振り返ってみると、どの疑問も自分が一度はぶち当たったことのあるものでした。今でも悩んでいる課題もありますが、上述したように「&lt;strong&gt;みんなでひとつの仕事をすればモブである&lt;/strong&gt;」と考えるようになってだいぶ肩の荷が下りました。もちろん方法論に沿ったほうがうまくいくことが多いとは思いますが、そこにこだわって悩むのではなく、&lt;strong&gt;方法に悩んだらそれすらモブで決めちゃおう&lt;/strong&gt;くらいの気持ちでいてもいいのかなと思います。せっかくなので楽しんでモブしたいですしね！ ハッピーモビング！&lt;/p&gt;</content><author><name></name></author><summary type="html">先日モブプロMeetupが開催されました。モブプロに関する知見や悩みが共有されて、モブプロの楽しさや難しさを再認識できる良い時間でした。</summary></entry><entry><title type="html">Babel7.4で非推奨になったbabel/polyfillの代替手段と設定方法</title><link href="https://aloerina01.github.io/blog/2019-06-21-1" rel="alternate" type="text/html" title="Babel7.4で非推奨になったbabel/polyfillの代替手段と設定方法" /><published>2019-06-21T00:00:00+00:00</published><updated>2019-06-21T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-06-21-1">&lt;p&gt;Babel7.4.0 から、長いことお世話になってきた @babel/polyfill が非推奨となりました。加えて、@babel/preset-env と @babel/ransform-runtime が core-js@3 に対応したようです🎉&lt;br /&gt;
これらに伴いpolyfill周りの設定方法が変わったので、その内容をメモしておこうと思います。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#babel-と-core-js-の関係のおさらい&quot; id=&quot;markdown-toc-babel-と-core-js-の関係のおさらい&quot;&gt;Babel と core-js の関係のおさらい&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#これからのpolyfill設定方法&quot; id=&quot;markdown-toc-これからのpolyfill設定方法&quot;&gt;これからのpolyfill設定方法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-preset-env-と-usebuiltinsusage-で必要なpolyfillだけ読み込む方法&quot; id=&quot;markdown-toc-1-preset-env-と-usebuiltinsusage-で必要なpolyfillだけ読み込む方法&quot;&gt;1. preset-env と useBuiltIns:usage で必要なpolyfillだけ読み込む方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-preset-env-と-usebuiltinsentry-で全polyfillを読み込む方法&quot; id=&quot;markdown-toc-2-preset-env-と-usebuiltinsentry-で全polyfillを読み込む方法&quot;&gt;2. preset-env と useBuiltIns:entry で全polyfillを読み込む方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-transform-runtime-を使う方法&quot; id=&quot;markdown-toc-3-transform-runtime-を使う方法&quot;&gt;3. transform-runtime を使う方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#proposal-の使い方&quot; id=&quot;markdown-toc-proposal-の使い方&quot;&gt;Proposal の使い方&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考&quot; id=&quot;markdown-toc-参考&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;babel-と-core-js-の関係のおさらい&quot;&gt;Babel と core-js の関係のおさらい&lt;/h3&gt;

&lt;p&gt;Babelが提供する @babel/polyfill や @babel/preset-env などのモジュールを利用すると&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;built-ins objects(Promise, WeakMap等)&lt;/li&gt;
  &lt;li&gt;static methods(Object.assign, Array.from等)&lt;/li&gt;
  &lt;li&gt;instance methods(Array.prototype.includes等)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった新しい機能を使った実装が可能になりますよね。これらのBabelモジュールは &lt;strong&gt;core-js&lt;/strong&gt; が提供するpolyfillを内部的に読み込んでいます。特に &lt;strong&gt;@babel/polyfill は core-js と regenerator-runtime を束ねて提供するpolyfill集&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;Babel7.4.0からはこの @babel/polyfill が非推奨になり、代わりに&lt;strong&gt;core-jsのバージョンを指定して直接読み込む&lt;/strong&gt;方法が提案されています。&lt;/p&gt;

&lt;h3 id=&quot;これからのpolyfill設定方法&quot;&gt;これからのpolyfill設定方法&lt;/h3&gt;
&lt;h4 id=&quot;1-preset-env-と-usebuiltinsusage-で必要なpolyfillだけ読み込む方法&quot;&gt;1. preset-env と useBuiltIns:usage で必要なpolyfillだけ読み込む方法&lt;/h4&gt;

&lt;p&gt;@babel/preset-env は(指定した実行環境にあわせた)必要な構文変換や、polyfillの読み込みをしてくれるものです。そしてこのpresetのオプションの&lt;code class=&quot;highlighter-rouge&quot;&gt;useBuiltins&lt;/code&gt;で「&lt;strong&gt;どのようにpolyfillを読み込むか&lt;/strong&gt;」を指定できます。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;useBuiltIns: usage&lt;/code&gt;とし、必要なpolyfillだけを読み込む設定例から見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@babel/prest-env をinstallする&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.babelrc または babel.config.js でオプションを指定する&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;presets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@babel/preset-env&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;useBuiltIns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;usage&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;corejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// or 2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指定したバージョンの core-js をinstallする&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; core-js@3  &lt;span class=&quot;c&quot;&gt;# or core-js@2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;useBuiltIns: usage&lt;/code&gt;とすると、コード内からpolyfillが必要な箇所を勝手に判断し、必要なcore-jsを勝手にimportしてくれます。このとき、&lt;strong&gt;core-js のバージョンも併せてオプションで指定し、それに応じた core-js をnpm installしておく必要がある&lt;/strong&gt;わけですね。&lt;/p&gt;

&lt;p&gt;ちなみに執筆時点の公式ドキュメントでは&lt;code class=&quot;highlighter-rouge&quot;&gt;useBuiltIns: usage&lt;/code&gt;はまだ&lt;strong&gt;experimental&lt;/strong&gt;となっているのですが、core-js@3 では多くの問題が解消されていてもはやexperimentalではないだろう…&lt;a href=&quot;https://github.com/babel/website/pull/1987/files#r265777607&quot; target=&quot;_blank&quot;&gt;とのこと&lt;/a&gt;です。&lt;/p&gt;

&lt;h4 id=&quot;2-preset-env-と-usebuiltinsentry-で全polyfillを読み込む方法&quot;&gt;2. preset-env と useBuiltIns:entry で全polyfillを読み込む方法&lt;/h4&gt;

&lt;p&gt;上記と同様に @babel/preset-env を使う方法ですが、オプションの内容が変わります。&lt;code class=&quot;highlighter-rouge&quot;&gt;useBuiltIns: entry&lt;/code&gt;とし、index.js などのjsファイルの先頭にてpolyfillをimportすることで、全部のpolyfillを読み込む方法です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@babel/prest-env をinstallする&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.babelrc または babel.config.js でオプションを指定する&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;presets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@babel/preset-env&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;useBuiltIns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;corejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// or 2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指定したバージョンの core-js と regenerator-runtime をinstallする&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; core-js@3  &lt;span class=&quot;c&quot;&gt;# or core-js@2&lt;/span&gt;
npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; regenerator-runtime
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jsファイルの先頭で core-js と regenerator-runtime をimportする&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;core-js/stable&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;regenerator-runtime/runtime&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// import &quot;@babel/polyfill&quot; 今まではこう指定していましたね&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;@babel/polyfill をimportしていた頃と同じ注意になりますが、core-js や regenerator-runtime 複数回importすると問題が起きる可能性があるので、bundleされるjsの冒頭で1度だけimportするように注意する必要があります。&lt;/p&gt;

&lt;h4 id=&quot;3-transform-runtime-を使う方法&quot;&gt;3. transform-runtime を使う方法&lt;/h4&gt;

&lt;p&gt;@babel/plugin-transform-runtime を使ってpolyfillを入れると、&lt;strong&gt;globalが汚染されないメリット&lt;/strong&gt;が得られる反面、&lt;strong&gt;instance methodsが使えないというデメリット&lt;/strong&gt;がありました。が、core-js@3に対応したことにより&lt;strong&gt;instance methodsが利用できるようになります&lt;/strong&gt;🎉&lt;/p&gt;

&lt;p&gt;設定の際は、bundleに組み込まれる &lt;strong&gt;@babel/runtime&lt;/strong&gt; と、ビルド時にpolyfill変換などを担う &lt;strong&gt;@babel/plugin-transform-runtime&lt;/strong&gt; を用意します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@babel/runtime と @babel/plugin-transform-runtime をinstallする&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; @babel/runtime
npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; @babel/plugin-transform-runtime
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.babelrc または babel.config.js でオプションを指定する&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;presets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@babel/plugin-transform-runtime&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;corejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指定したバージョンの core-js をinstallする&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; core-js@3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;proposal-の使い方&quot;&gt;Proposal の使い方&lt;/h3&gt;

&lt;p&gt;@babel/preset-env または @babel/plugin-transform-runtime どちらを利用する場合であっても、core-js@3 ではProposalの機能も利用できるようになりました。設定方法はオプションの内容を変更するだけです。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// before&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;corejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// after&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;nl&quot;&gt;corejs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proposals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;公式ドキュメントには「ECMAScriptの提案は本質的に不安定であり、core-js@4 では変わる可能性があります」との注意書きがありますので、ご承知おきを。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/babel/website/pull/1987&quot; target=&quot;_blank&quot;&gt;https://github.com/babel/website/pull/1987&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://babeljs.io/docs/en/next/babel-polyfill.html&quot; target=&quot;_blank&quot;&gt;https://babeljs.io/docs/en/next/babel-polyfill.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-runtime&quot; target=&quot;_blank&quot;&gt;https://babeljs.io/docs/en/babel-plugin-transform-runtime&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot; target=&quot;_blank&quot;&gt;https://babeljs.io/docs/en/babel-preset-env&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://babeljs.io/blog/2019/03/19/7.4.0&quot; target=&quot;_blank&quot;&gt;https://babeljs.io/blog/2019/03/19/7.4.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md&quot; target=&quot;_blank&quot;&gt;https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Babel7.4.0 から、長いことお世話になってきた @babel/polyfill が非推奨となりました。加えて、@babel/preset-env と @babel/ransform-runtime が core-js@3 に対応したようです🎉 これらに伴いpolyfill周りの設定方法が変わったので、その内容をメモしておこうと思います。</summary></entry><entry><title type="html">コーチング入門 「4つの会話」でやる気の芽を育てよう</title><link href="https://aloerina01.github.io/blog/2019-05-07-1" rel="alternate" type="text/html" title="コーチング入門 「4つの会話」でやる気の芽を育てよう" /><published>2019-05-07T00:00:00+00:00</published><updated>2019-05-07T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-05-07-1">&lt;p&gt;ここ最近、マネジメントの一貫として「1ヶ月間コーチング」に取り組んでいます。クライアント(コーチング相手になってくれる方)と1ヶ月間じっくりコミュニケーションをとって、目標の見直しから実現まで様々な段階に付き添わせてもらいました。&lt;/p&gt;

&lt;p&gt;ある程度自分の中でやり方が見えてきたので、経験談とそれを通して得た考え方について現時点のスナップショットを残しておこうと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2019-04-25-1-coaching.jpg&quot; alt=&quot;グラレコ&quot; /&gt;
&lt;small&gt;今回の概要をグラレコ形式でまとめてみました。&lt;/small&gt;&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前提&quot; id=&quot;markdown-toc-前提&quot;&gt;前提&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#コーチングとは&quot; id=&quot;markdown-toc-コーチングとは&quot;&gt;コーチングとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#コーチングに必要な人間関係&quot; id=&quot;markdown-toc-コーチングに必要な人間関係&quot;&gt;コーチングに必要な人間関係&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#コーチングで使った4つの会話&quot; id=&quot;markdown-toc-コーチングで使った4つの会話&quot;&gt;コーチングで使った4つの会話&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#承認する&quot; id=&quot;markdown-toc-承認する&quot;&gt;承認する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#質問する&quot; id=&quot;markdown-toc-質問する&quot;&gt;質問する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#整理する&quot; id=&quot;markdown-toc-整理する&quot;&gt;整理する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#リクエストする&quot; id=&quot;markdown-toc-リクエストする&quot;&gt;リクエストする&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#やる気の芽の育て方&quot; id=&quot;markdown-toc-やる気の芽の育て方&quot;&gt;やる気の芽の育て方&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-ゴール目標が明確になる&quot; id=&quot;markdown-toc-1-ゴール目標が明確になる&quot;&gt;1. ゴール・目標が明確になる&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-ゴールまでのプロセスが明確になる&quot; id=&quot;markdown-toc-2-ゴールまでのプロセスが明確になる&quot;&gt;2. ゴールまでのプロセスが明確になる&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-自分が描いたゴールプロセスに自信を持つ&quot; id=&quot;markdown-toc-3-自分が描いたゴールプロセスに自信を持つ&quot;&gt;3. 自分が描いたゴール・プロセスに自信を持つ&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4-ゴールプロセスを必要に応じて見直せる&quot; id=&quot;markdown-toc-4-ゴールプロセスを必要に応じて見直せる&quot;&gt;4. ゴール・プロセスを必要に応じて見直せる&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5-自分のペースでプロセスを継続する&quot; id=&quot;markdown-toc-5-自分のペースでプロセスを継続する&quot;&gt;5. 自分のペースでプロセスを継続する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#まとめ&quot; id=&quot;markdown-toc-まとめ&quot;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;前提&quot;&gt;前提&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1対1でやる&lt;/li&gt;
  &lt;li&gt;内容はクライアントのキャリアや仕事に関係すること&lt;/li&gt;
  &lt;li&gt;コミュニケーションはオンライン・オフライン両方で柔軟にとる&lt;/li&gt;
  &lt;li&gt;コミュニケーションのタイミングは必要に応じて随時&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私がやってきたコーチングはこんな感じでした。&lt;/p&gt;

&lt;h3 id=&quot;コーチングとは&quot;&gt;コーチングとは&lt;/h3&gt;

&lt;p&gt;コーチングとは&lt;strong&gt;クライアントの「やりたい」気持ちを実現に導くこと&lt;/strong&gt;だと理解しています。言い換えれば「やる気を出させる」ことなどはコーチングの領域には含まれず、あくまでクライアントの自主的な行動や気持ちに対してアプローチするのがコーチングであるということです。&lt;/p&gt;

&lt;p&gt;そして、コーチングは現実に導くために直接的に手助けするわけではなく、&lt;strong&gt;クライアント自身の気付きによって前進するよう、会話を通して間接的に手助けする&lt;/strong&gt;ものだと考えています。&lt;/p&gt;

&lt;h3 id=&quot;コーチングに必要な人間関係&quot;&gt;コーチングに必要な人間関係&lt;/h3&gt;

&lt;p&gt;コーチングだけでなくマネジメントなどにも言えることだと思いますが、&lt;strong&gt;信頼関係が必須&lt;/strong&gt;だと痛感しました。クライアントに信頼されることはもちろん、コーチがクライアントを信じ切ることも大切なことだと思います。&lt;/p&gt;

&lt;p&gt;自己開示し合えるだけの関係性が必要ですし、人が気持ちを揺さぶられたり行動を起こしたりするには「誰に言われたか」も大事な要素だったりします。なので、場合によってはコーチングを始める前に関係づくりの期間をとることも必要だと感じました。&lt;/p&gt;

&lt;h3 id=&quot;コーチングで使った4つの会話&quot;&gt;コーチングで使った4つの会話&lt;/h3&gt;

&lt;p&gt;コーチングする上で大切なことは「聞く」スキルだと言われたりします。ですが相手が一方的にたくさん話してくれるなんてことはそうそうないので、こちらから「話す」ことも必要になってきます。なので今回は「聞く」でも「話す」でもなく、互いに話し聞く「会話」に焦点を当てて、コーチングで実際に行った4つの会話をまとめます。&lt;/p&gt;

&lt;h4 id=&quot;承認する&quot;&gt;承認する&lt;/h4&gt;

&lt;p&gt;ここで言う「承認」とは &lt;strong&gt;Approve ではなく Acknowledge を指します&lt;/strong&gt;。単に成果を認めるだけはなく、まずクライアントの存在そのものを認め、感謝し、クライアントに現れている変化や違いや成長に気付き、それを言語化して伝えます。&lt;/p&gt;

&lt;p&gt;クライアントのやろうとしていることを理解し認める意志を伝えることは、信頼関係を築くために必要なことですし、コーチングをする上で必要な心構えでもあると感じています。&lt;/p&gt;

&lt;h4 id=&quot;質問する&quot;&gt;質問する&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;「答えはクライアント自身が持っている」前提に立ち、質問を通して気付きを得てもらいます&lt;/strong&gt;。答えのない問いに耽っていると、どうしても思考が行き詰まったり、どう考えるべきかわからなくなる場面があります。そんな場面に出くわしたクライアントに&lt;strong&gt;新しい視点を与える&lt;/strong&gt;よう質問することが必要です。&lt;strong&gt;リフレーミング&lt;/strong&gt;と言ったりもしますね。&lt;br /&gt;
具体的には、&lt;strong&gt;Why や How&lt;/strong&gt; を尋ねる質問が中心になります。&lt;/p&gt;

&lt;h4 id=&quot;整理する&quot;&gt;整理する&lt;/h4&gt;

&lt;p&gt;クライアントが悩み続けてしまったり思考が堂々巡りしてしまったりと、思考が拡散してしまったときに現状を整理して伝えます。考えを深掘りする方法のひとつに「なぜ？を繰り返し問う」方法がありますが、一人でこれをしていると思考が行き詰まりがちです。クライアントがなぜなぜの袋小路に入ってしまったときに、&lt;strong&gt;整理して伝えたり図示して見せたりすることで、それまで考えていたことを客観的に見返す手助けとなります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;また、クライアントの考えを正しく理解できているか確認するため、発言内容を整理して「〜という理解であっていますか？」と尋ねることもあります。&lt;/p&gt;

&lt;h4 id=&quot;リクエストする&quot;&gt;リクエストする&lt;/h4&gt;

&lt;p&gt;会話で必要なものを用意してもらうよう依頼したり、考え方のフレームワークを提案したりします。&lt;br /&gt;
クライアントは自分の目的のために必要なアクションを&lt;strong&gt;自分自身で見つけてくれるはず&lt;/strong&gt;ですので、「次回までにこれをしてきて」といったような直接的なリクエストはあまりしません。やり方がわからないクライアントに対して「必要ならこういう考え方を試してみて」と提案する等、&lt;strong&gt;アイデアを貸す&lt;/strong&gt;ような感覚でリクエストをします。リクエストは最後の手段だと認識しています。&lt;/p&gt;

&lt;h3 id=&quot;やる気の芽の育て方&quot;&gt;やる気の芽の育て方&lt;/h3&gt;
&lt;p&gt;コーチングの有無に限らず、私たちが何かを成し遂げたいと思ったとき、それを達成するまでに辿る段階があります。人によっては飛ばしたり細分化したりするとは思いますが、大まかには以下の5つのステップで考えました。&lt;/p&gt;

&lt;h4 id=&quot;1-ゴール目標が明確になる&quot;&gt;1. ゴール・目標が明確になる&lt;/h4&gt;

&lt;p&gt;「どうなりたいか」という到達目標であったり、「どうありたいか、どう過ごしていたいか」という継続目標であったり、種類は様々ですが、目標を明確にすることが最初の一歩目です。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;いいエンジニアになりたい&lt;/li&gt;
  &lt;li&gt;南国で暮らしていきたい&lt;/li&gt;
  &lt;li&gt;每日1つ何かしらのアウトプットをしていきたい&lt;/li&gt;
  &lt;li&gt;このままじゃ自分のキャリアが不安なので何か始めたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらは過去に私が立てた目標ですが、このようにどんな目標でも良いと思います。漠然な内容でも、定性的なことでも、遠い将来の夢の通過点であっても、何であれ&lt;strong&gt;そこにやる気の種&lt;/strong&gt;があればまずはOKです。やる気を持つこと自体が素敵で素晴らしいことのはずです。&lt;/p&gt;

&lt;p&gt;そして&lt;strong&gt;やる気の種を一緒に育てていくのがコーチング&lt;/strong&gt;です。どんな種でも自信を持ってもらいましょう。そのために「承認」し、必要に応じて不安や曖昧さを解消するために「質問」し「整理」します。&lt;/p&gt;

&lt;h4 id=&quot;2-ゴールまでのプロセスが明確になる&quot;&gt;2. ゴールまでのプロセスが明確になる&lt;/h4&gt;

&lt;p&gt;ゴールや目標を達成するために必要なプロセス・マイルストーン・TODOを明確にします。正確である必要はないので、大まかに&lt;strong&gt;いつまでにどうなっていればよいか&lt;/strong&gt;を定めます。ポイントは3つです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;近い将来のことは具体的に、遠い将来のことはざっくりと&lt;/strong&gt;決める&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;定量的な達成基準&lt;/strong&gt;を設ける&lt;/li&gt;
  &lt;li&gt;必ずやれると&lt;strong&gt;コミットできる内容&lt;/strong&gt;にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;プロセスは定期的に見直していくものなので、近い将来のTODOが具体的であれば十分です。ただし、実現できない可能性のあるTODO(運や環境に左右されること、ハードルが高すぎること)は控えます。&lt;br /&gt;
例えば私の場合は「1ヶ月に10冊本を読む」よりは「1日30分本を読む」のほうが適切でした。私の読書スピードは本の難易度に依存するため、冊数を基準にすると達成できない可能性があったので、1日に読書に充てる時間を基準にしました。&lt;/p&gt;

&lt;p&gt;このステップでのコーチングは、「質問」がメインになります。ゴール(または途中の地点)に到達する姿がイメージできるくらいまで「質問」を繰り返してプロセスを明確にしていきます。&lt;/p&gt;

&lt;h4 id=&quot;3-自分が描いたゴールプロセスに自信を持つ&quot;&gt;3. 自分が描いたゴール・プロセスに自信を持つ&lt;/h4&gt;

&lt;p&gt;自分ひとりで考えて、目標やプロセスを決めて、黙々と努力する……。そうしているうちに「このやり方であっているのか」「これを続けていて意味があるのか」と不安が湧き出てしまうことは、努力する人には至極自然なことなのだと思います。&lt;/p&gt;

&lt;p&gt;この不安を乗り越えられるよう描いたゴールやプロセスに自信を持っていきたいですよね。そのためには、日々の努力を「承認」することも大事ですが、なぜそのプロセスを設定したのかを思い返すように「質問」することも役立ちます。最終的には、自信の根拠はクライアント自身のやる気にたどり着くものなのだと思います。&lt;/p&gt;

&lt;h4 id=&quot;4-ゴールプロセスを必要に応じて見直せる&quot;&gt;4. ゴール・プロセスを必要に応じて見直せる&lt;/h4&gt;

&lt;p&gt;経験を積めば考え方や視点は変化していきます。また時間の経過により環境が変わったりもします。ですので、自分の目標やプロセスに疑問を感じたら都度見直すことが必要です。&lt;/p&gt;

&lt;p&gt;見直しの段階でのコーチングは、やはり「質問」や「整理」が中心なります。ただし、ここでのコーチングの目標は「クライアントが見直しに成功すること」ではなく、「&lt;strong&gt;クライアントがいつでも一人で目標の見直しをできるようになること&lt;/strong&gt;」です。どんなときに、どのように、どのくらい見直しすべきかの感覚がクライアントに浸透するように、考える場面を多く与えます。&lt;/p&gt;

&lt;h4 id=&quot;5-自分のペースでプロセスを継続する&quot;&gt;5. 自分のペースでプロセスを継続する&lt;/h4&gt;

&lt;p&gt;目標に対して常に100％のモチベーションやエネルギーを維持するのって、実はけっこう大変ですよね。ですので、&lt;strong&gt;やる気に応じて、どれだけがんばるかをコントロールしながら継続できれば十分&lt;/strong&gt;だと思います。&lt;/p&gt;

&lt;p&gt;目標次第では「やる気の上下に関わらず無理してでも100％がんばる」というコントロールが必要かもしれませんし、「やる気がないときはプロセスの達成基準の50％を維持する」でも良いと思います。何であれ、クライアント自身がこのコントロールをできるようになることがコーチングの目標になります。&lt;/p&gt;

&lt;p&gt;ここでの会話は「承認」も良いですが、&lt;strong&gt;クライアントが自身のモチベーション・エネルギー源がどこにあるのかを自覚する&lt;/strong&gt;よう「質問」することも役立ちます。また成果や経過を共有できるコミュニティを探すよう「リクエスト」することもあるかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;これらの5つのステップを行ったり来たりしながら目標達成を目指すのが、私の考える「やる気の芽の育て方」です。コーチングの行為は、4つの会話を使ってクライアントと一緒にやる気の芽を育てることですが、最終目標はクライアントが一人で育てられるようになることだということを忘れず、クライアントの自発心を刺激し続ける意識で取り組みました。&lt;/p&gt;

&lt;p&gt;今後も引き続きコーチングを続けて考え方や方法をアップデートしていこうと思います。コーチングについて経験豊富な先輩方、アドバイス等あれば是非&lt;a href=&quot;https://twitter.com/aloerina_&quot; target=&quot;_blank&quot;&gt;@aloerina_&lt;/a&gt;までご連絡ください。&lt;/p&gt;</content><author><name></name></author><summary type="html">ここ最近、マネジメントの一貫として「1ヶ月間コーチング」に取り組んでいます。クライアント(コーチング相手になってくれる方)と1ヶ月間じっくりコミュニケーションをとって、目標の見直しから実現まで様々な段階に付き添わせてもらいました。</summary></entry><entry><title type="html">テックリードになる前後にやっていたこと</title><link href="https://aloerina01.github.io/blog/2019-04-15-1" rel="alternate" type="text/html" title="テックリードになる前後にやっていたこと" /><published>2019-04-15T00:00:00+00:00</published><updated>2019-04-15T00:00:00+00:00</updated><id>https://aloerina01.github.io/blog/1</id><content type="html" xml:base="https://aloerina01.github.io/blog/2019-04-15-1">&lt;p&gt;主業務で関わっているプロダクトにおいて、2018年中頃あたりからフロントエンドのテックリードを担当していました。今はチームマネジメントに重きを置きつつ、次のテックリードにバトン渡しをしている段階です。&lt;/p&gt;

&lt;p&gt;テックリードになる前後でどんなことを考えていたのか、どんなことをしていたのかをふと振り返ってみたのでメモを残します。&lt;/p&gt;

&lt;h3 id=&quot;環境前提条件&quot;&gt;環境・前提条件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;プロダクトについて
    &lt;ul&gt;
      &lt;li&gt;5年以上続いているプロダクト&lt;/li&gt;
      &lt;li&gt;フロントエンドエンジニアが触るリポジトリが4つ&lt;/li&gt;
      &lt;li&gt;bundleされるjsが複数あり、フレームワークや設計が全部違う
        &lt;ul&gt;
          &lt;li&gt;Vue・React・内製フレームワークを利用&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;プロジェクトについて
    &lt;ul&gt;
      &lt;li&gt;プロジェクトメンバー増加中(40〜50人)&lt;/li&gt;
      &lt;li&gt;伴って、調整ごとが多い(仕様、スコープ、スケジュール等)&lt;/li&gt;
      &lt;li&gt;伴って、開発フロー等の見直しが必要な状況&lt;/li&gt;
      &lt;li&gt;プランニング→デザイン→サーバ開発→フロント開発→QA→リリース&lt;br /&gt;
というウォーターフォール風の開発フロー&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;フロントエンドのチームについて
    &lt;ul&gt;
      &lt;li&gt;フロントエンドとバックエンドは分業制&lt;/li&gt;
      &lt;li&gt;フロントエンドチームは4〜6人(増減期だった)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;私について
    &lt;ul&gt;
      &lt;li&gt;当時、社歴1年半くらい&lt;/li&gt;
      &lt;li&gt;当時、プロダクト歴はチームで2番目くらいの長さになった&lt;/li&gt;
      &lt;li&gt;プロダクトのフロントエンドのソースはだいたい触った&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;テックリードになる前に考えていたこと&quot;&gt;テックリードになる前に考えていたこと&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;プロダクト歴が長くなってきたので、一番詳しい人でいよう&lt;/li&gt;
  &lt;li&gt;自分は集中力がなく長時間開発に専念できないので、みんなに代わって会議に出よう&lt;/li&gt;
  &lt;li&gt;自分のスケジュールは当然自分で調整する、ついでにチームメンバーのスケジュールも(必要なら)調整しよう&lt;/li&gt;
  &lt;li&gt;メンバーが増えてきたのでメンテしやすい設計を守っていこう&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;テックリードになる前にやっていたこと&quot;&gt;テックリードになる前にやっていたこと&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;コードレビューをチームに導入する&lt;/li&gt;
  &lt;li&gt;全部のPRに対してコードレビューをする&lt;/li&gt;
  &lt;li&gt;全部の会議に出る&lt;/li&gt;
  &lt;li&gt;プロダクトに関わる他の職種の人といっぱい雑談してつながりを増やす&lt;/li&gt;
  &lt;li&gt;CIのメンテやタスクの管理などの開発以外の業務を積極的に担当する&lt;/li&gt;
  &lt;li&gt;その他雑用を巻き取る&lt;/li&gt;
  &lt;li&gt;チームの稼働率や案件進捗を可視化する&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ここまでのまとめ&quot;&gt;ここまでのまとめ&lt;/h3&gt;

&lt;p&gt;思い返してみると、当時はテックリードという名前や役割についてあまり理解していなかったです。エンジニアとして開発業務をする傍ら、ミーティングに出たりスケジュールやスコープの調整をしたりとコミュニケーション業務や雑務をしていた感じです。&lt;/p&gt;

&lt;p&gt;この期間をしばらく経てテックリードという言葉を知り、自分の次のステップだと意識したことを覚えています。マネージャーとの1on1でテックリード目指す旨を伝え、社内では「Development Leader」という呼び名であることを教えてもらいました。&lt;/p&gt;

&lt;p&gt;テックリードを意識したあとも業務内容はあまり変わらなかったのですが、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;コードの品質&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;チームの生産性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;アーキテクチャ・設計&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を守ることについて殊更意識するようになりました。同時に、「チームの状態」をマネージャーやステークホルダーに見せることも自分の仕事と認識するようになり、状況共有や可視化をし始めた記憶があります。&lt;/p&gt;

&lt;p&gt;あと忘れてはならないことは、好き勝手やっていた自分をチームメンバーが受け入れてくれたことです。誰かが何かを提案したときに「とりあえずやってみよう」と言ってくれるチームメンバーには感謝が尽きません。&lt;/p&gt;

&lt;h3 id=&quot;テックリードになってからやったこと&quot;&gt;テックリードになってからやったこと&lt;/h3&gt;

&lt;p&gt;テックリードのような役割を明確に任されるようになった後は、それまで以上にチームの技術力を底上げすることを意識しました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;コードレビュー会を開催してみんなの視点・観点を共有し合う&lt;/li&gt;
  &lt;li&gt;大きな案件やチャレンジングな案件をメンバーに任せる&lt;/li&gt;
  &lt;li&gt;任せた案件のサポート・相談役を担う&lt;/li&gt;
  &lt;li&gt;チームを割り込み作業から守る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当時はチームメンバーがいかに快適に開発できるか、開発に専念できるか、ばかり考えていたと思います。大きな開発案件を担当することが減ったので手持ち無沙汰に感じる場面もありましたが、その時間を使って開発フローや環境の改善に取り組めたりしたので、けっこう充実していました。&lt;/p&gt;

&lt;p&gt;ただ、それまで以上にコミュニケーションハブとしての責任が大きくなり、その方法で悩んだり反省したりといったことも多かった時期でもありました。&lt;/p&gt;

&lt;h3 id=&quot;テックリードになっても考えなかったことおまけ&quot;&gt;テックリードになっても考えなかったこと(おまけ)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;チームメンバーのキャリアなどのマネジメント&lt;/li&gt;
  &lt;li&gt;プロダクトの売上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この頃は「いちエンジニアとしてやれることならやる」というスタンスで、マネジメント業務には抵抗感を持っていました(マネジメント業務が何かもわかっていませんでしたが…)。また、チームのアウトプット量を増やすことは意識していたものの、それがどれほど売上にインパクトを与えるかまでは考えていませんでした。&lt;/p&gt;

&lt;p&gt;これらを考えなかったことの善し悪しは別として、「これはやりたくない・興味がない」と勝手に線引して視野を狭めていたことは反省点のひとつです。&lt;/p&gt;

&lt;h3 id=&quot;おわりに&quot;&gt;おわりに&lt;/h3&gt;

&lt;p&gt;まとめると、テックリードになる前後でやってたことは大幅には変わりませんでしたが、意識していたことは徐々に移り変わっていた、という感じでした。そのうちマネジメントになる前後のことも棚卸ししてみたいと思います。&lt;/p&gt;</content><author><name></name></author><summary type="html">主業務で関わっているプロダクトにおいて、2018年中頃あたりからフロントエンドのテックリードを担当していました。今はチームマネジメントに重きを置きつつ、次のテックリードにバトン渡しをしている段階です。</summary></entry></feed>