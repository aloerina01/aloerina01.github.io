---
title: 俺がやらかしたVue mixinのアンチパターンから学ぶmixinの使い方
outline: 
categories: ['Vue', 'JavaScript']
---

### Vue の mixin とは

> Vue コンポーネントに再利用可能で柔軟性のある機能を持たせるための方法です。  
> (中略)  
> ミックスインの全てのオプションはコンポーネント自身のオプションに”混ぜられ”ます。

公式ドキュメントにあるように、Vueコンポーネント間で再利用可能な部品をつくるための機能がmixinです。mixinでコンポーネントの一部を共通化する例はよく見かけますし、私もしばしばやってきました。ただ、どうも自分の実装方法だと後々不便になったり見通しが悪かったりと、使い勝手の悪いものになってしまうことが多かったです。

これはもしかしてアンチパターンなのでは？ と思ったので、自分なりのmixinの解釈と実用法(または代替案)をまとめてみました。

<div class="note">
<p>この記事で紹介する実装例は、私の関わるプロダクトではデメリットの方が大きかった実装方法です。</p>

便宜上「アンチパターン」「失敗例」といった表現をしますが、<b>個人的にやりたくないパターン</b>程度の意味合いであり、世論一般的によろしくないものというわけではありませんのでご理解ください。
</div>

* TOC
{:toc}

### 失敗例1. 継承とOverrideを意識したmixin



#### サンプルコード

クラスの親子関係のように、Componentに必須のmethodsを継承して使う、またはOverrideして使うことを想定したmixinです。

以下のサンプルコードは、とある1画面を表現する MainPageContainer.vue と、どの画面にも必要な共通処理を抜き出した pageContainerMixin.js です。

**pageContainerMixin.js**
```js
export default {
  created() {
    document.title = this.getTitle();
  },
  mounted() {
    this.sendPageview();
  },
  methods: {
    getTitle() {
      throw new Error('You must override this function.');
    },
    sendPageview() {
      ga('send', 'pageview');
    },
  }
}
```

<p></p>

**MainPageContainer.vue**
```html
<template>
  <!-- 省略 -->
</template>

<script>
import pageContainerMixin from './pageContainerMixin';

export default {
  mixins: [ pageContainerMixin ],
  methods: {
    getTitle() {
      return 'メインページ';
    }
  }
}
</script>
```

<p></p>

mixinの中にはOverrideして使われることを想定した`getTitle`関数が実装されていますね。**Overrideされなかった場合に例外を投げて**教えてくれます。

また、mixinの中ではライフサイクルメソッドから`sendPageview`関数などを暗黙的に呼び出していて、その処理の中身を変えたいときはOverrideし派生させる仕組みにもなっています。

#### 暗黙的挙動の危うさ

**Containerに必須の処理をmixinに閉じ込め暗黙的に実行させた**ことで、チームメンバーが誰でも簡単に新規Containerを実装できるようになったと当初は満足していました。

しかしアプリケーションが大きくなりContainer毎の独自の仕様が必要になったとき、またはメンバーが新規参入してきたとき、暗黙的に実行される処理の中身やそのOverride方法を読み解く必要性が出てきました。言い換えれば、ちゃんと読み解かないとバグを生みやすい箇所に化けた、ということです。

Vueなどのように知識が一般化されたフレームワークの暗黙的挙動ならまだしも、こういった**「独自の暗黙的挙動」は負担になりやすい**ので注意が必要です。そのためmixin実装直後は良くても、時間が経つことで負債に化けるパターンでした。

#### OverrideではなくMergeしているだけ


#### Classの継承とmixinは本質的に違う




### 失敗例2. Decoratorパターンを意識したmixin

#### サンプルコード

継承(のような)関係でmixinを使うことに危機感を覚えて以後は、もっとシンプルに**依存関係の少ない単発の機能を付与する**mixinを、以下の2つのルールに基づいて実装していきました。

* JavaなどのInterfaceにあるように「〇〇able」という命名をする
* 他のモジュールに依存しない(importしない)

以下は、PC版Twitterのフォロワー一覧画面のように、ユーザープロフィールがカード型の一覧で並ぶ画面のサンプルコードです。画面内で使われるカードコンポーネント ProfileCard.vue と、もっと読むボタン等などでよく見る「開閉させる機能」を提供する expandable.js というmixinの実装です。

**expandable.js**
```js
export default {
  data() {
    return {
      isExpanded: false, // 初期値を変えたい場合はComponentでOverrideする
    }
  },
  methods: {
    toggleExpand() {
      this.isExpanded = !this.isExpanded;
    }
  }
}
```

<p></p>

**ProfileCard.vue**
{% raw %}
```html
<template>
  <div>
    <div v-show="!isExpanded"><!-- プロフィールの概要 --></div>
    <div v-show="isExpanded"><!-- プロフィールの詳細 --></div>
    <button @click="toggleExpand">{{ buttonLabel }}</button> 
  <div>
</template>

<script>
import expandable from './expandable';

export default {
  mixins: [ expandable ],
  computed: {
    buttonLabel() {
      return this.isExpanded ? '折りたたむ' : 'もっと見る';
    }
  }
}
</script>
```
{% endraw %}

<p></p>



expandableは何にも依存せず、シンプルに「開閉ステータス」と「開閉させる関数」だけを持っています。名前からもその機能が提供されることが予測できますね。コンポーネント側も、(正確にはDecoratorパターンとは違いますが)mixinで柔軟かつ簡潔に機能を付け外しできていることがわかります。

#### 名前競合にまつわる問題

ただ注意しなければならないのは、名前の競合が起きることです。これはmixinを使う以上当たり前の話ではあるのですが、mixin一つ一つがシンプルな機能なだけに、dataやmethodsの命名もシンプルになりがちで競合が起きやすくなります。  
それを回避しようとすると今回のサンプルのように`isExpanded`とわざとらしく被らない命名になったり(`isOpened`を避けました)、長い名前になったりします。

逆に、コンポーネント側で同じ名前を定義しOverrideにより処理を上書いている場合、mixin側を安易に変更できなくなります。これは失敗例1にも言えることですが、mixinがオブジェクトのマージなので、OverrideをIDEやコンパイラで検知できないことに起因します。

せっかくmixinでコードを分離しているのに、関心は分離されず、


### ViewModelにおける共通化・再利用とは


3. なぜ微妙だったか
  Componentのソース見ただけではComponentの全容がわからない状態になってしまう
  見えないところでthisに依存されている(componentからみたら)
  thisの中身がかわる(mixinからみたら)→あらゆる用途を想像できないケースが多い
  Overrideするにも、inputもoutputも型定義がないとなんでもアリになっちゃう
  名前の競合が起きることがある
  マージストラテジが知らず知らずのうちに変わっている可能性がある
4. ViewModelにおける「共通化」の必要性
  VMはViewと1on1で結びつくものなので、VM同士での共通化とか考えなくていい
  それでも明らかに同じ雑務が必要なときはUtilクラスにまとめたりするでしょ？
  また、どのModelにも属さず、どのViewModelにも属さない処理やビジネスロジックってあるでしょ？
  それをServiceクラスにするのと同じ
  Utilと同じように、純粋関数として抜き出してパッケージングするのが良い
  Service, Util, Helperなどとしてパッキングする
5. 対処法
  それ本当にmixinにする必要ある？共通化したいだけならServiceクラス、Utilクラス
  状態に依存するなら参照透過性をもたせる
  computedにしたいなら参照透過性をもたせる
  ライフサイクルに暗黙的に組み込みたいならmixinを使うのが良い、でも「暗黙的」はリスクのほうが多そうなので結局使わない



Vueのmixinってあるじゃないですか。Componentの中身の共通化で使うやつ。

公式にも

> Vue コンポーネントに再利用可能で柔軟性のある機能を持たせるための方法です。

って書いてあります。
でも正直にmixnでガンガン共通化していたら、あとあと苦労することになりました。mixinがもつ欠点(利用する際に考慮するべき点)を正しく把握して使う必要がありそうです。

### Vue mixinの欠点(になりうる点)

概念としても差がある
mixin = 抜き出し＆共通化
extends = 基底と派生

動作としても差がある
mixin = オブジェクトのマージ
extends = JSならprototype継承

#### Classの継承ではない


私が最初にやったアンチパターンの例は、Classの継承と似たように捉えたこと。この時点ではmixinの性質を誤認していただけでなく、継承の役割も誤認していたので散々だった。

前提としてClass継承とは「基底クラス」を継承して「派生クラス」をつくること。つまり共通処理を抜き出して親クラスにまとめることではなくて、親クラスの一部の処理を派生させるもの。

で、mixinはというと、やっていることはObjectのマージ。そのため名前衝突が起こることもあるし、オブジェクトのマージを利用したOverride等の独自ルールがあったとしても見落とすことがあるし、マージストラテジも可変だし、mixinされる側の状態に依存してしまうと目コンパイルでエラーを予測できないし、いろいろ大変だ。

#### ViewModelの責任範囲から考える
Viewに紐づくDataの取り回しが責務

つまりViewと同等の単位で分けられている以上、無理に共通化せずとも、似たような処理がViewModel同士に存在してもいい。だってそれらはそれぞれのViewのための処理であって、互いは排他的だから。こっちのViewModelの処理Aを変えたからって、こっちのViewModelの処理A'まで変える必要はない。


### 対処法

- 処理を共通化したいだけなら純粋関数でService/Util化
- ライフサイクルでの呼び出しを強制したいなら…？
- 各Componentで毎回同じ処理を呼び出すのを省略したいなら、それは毎回書く！

ただ、そもそも似た役割のViewが存在し、それらに紐づくViewModelが存在する場合、それらの中に完全に共通の処理が含まれることもなくはない。

そういった時の基本的な対応方法はスタティックで参照透過な関数をServiceとして抜き出す方法。(mixinではなく！)

クラスベースな言語の世界だとServiceクラスっていうので、それに習ってServiceクラスと書きますが、別にClassでなくてもいいです。

で、共通処理は純粋関数として抜き出して、意味合い毎にひとつに束ねて提供するのがどうでしょうか？という話です。例えばサムネイルリストComponentとテキストリストComponentとGridComponentのそれぞれがcomputedにsort処理を持つ場合、それをmixinにするのではなく、ただのjs関数として抜き出す。

