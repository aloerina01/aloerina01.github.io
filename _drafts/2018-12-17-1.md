---
title: 俺がやらかしたVue mixinのアンチパターンから学ぶmixinの使い方
outline:
categories: ['Vue', 'JavaScript']
---

Vueのmixinってあるじゃないですか。Componentの中身の共通化で使うやつ。

公式にも

> Vue コンポーネントに再利用可能で柔軟性のある機能を持たせるための方法です。

って書いてあります。
でも正直にmixnでガンガン共通化していたら、あとあと苦労することになりました。mixinがもつ欠点(利用する際に考慮するべき点)を正しく把握して使う必要がありそうです。

### Vue mixinの欠点(になりうる点)

概念としても差がある
mixin = 抜き出し＆共通化
extends = 基底と派生

動作としても差がある
mixin = オブジェクトのマージ
extends = JSならprototype継承

#### Classの継承ではない


私が最初にやったアンチパターンの例は、Classの継承と似たように捉えたこと。この時点ではmixinの性質を誤認していただけでなく、継承の役割も誤認していたので散々だった。

前提としてClass継承とは「基底クラス」を継承して「派生クラス」をつくること。つまり共通処理を抜き出して親クラスにまとめることではなくて、親クラスの一部の処理を派生させるもの。

で、mixinはというと、やっていることはObjectのマージ。そのため名前衝突が起こることもあるし、オブジェクトのマージを利用したOverride等の独自ルールがあったとしても見落とすことがあるし、マージストラテジも可変だし、mixinされる側の状態に依存してしまうと目コンパイルでエラーを予測できないし、いろいろ大変だ。

#### ViewModelの責任範囲から考える
Viewに紐づくDataの取り回しが責務

つまりViewと同等の単位で分けられている以上、無理に共通化せずとも、似たような処理がViewModel同士に存在してもいい。だってそれらはそれぞれのViewのための処理であって、互いは排他的だから。こっちのViewModelの処理Aを変えたからって、こっちのViewModelの処理A'まで変える必要はない。


### 対処法

- 処理を共通化したいだけなら純粋関数でService/Util化
- ライフサイクルでの呼び出しを強制したいなら…？
- 各Componentで毎回同じ処理を呼び出すのを省略したいなら、それは毎回書く！

ただ、そもそも似た役割のViewが存在し、それらに紐づくViewModelが存在する場合、それらの中に完全に共通の処理が含まれることもなくはない。

そういった時の基本的な対応方法はスタティックで参照透過な関数をServiceとして抜き出す方法。(mixinではなく！)

クラスベースな言語の世界だとServiceクラスっていうので、それに習ってServiceクラスと書きますが、別にClassでなくてもいいです。

で、共通処理は純粋関数として抜き出して、意味合い毎にひとつに束ねて提供するのがどうでしょうか？という話です。例えばサムネイルリストComponentとテキストリストComponentとGridComponentのそれぞれがcomputedにsort処理を持つ場合、それをmixinにするのではなく、ただのjs関数として抜き出す。

