---
title: 俺がやらかしたVue mixinのアンチパターンから学ぶmixinの使い方と代替案
outline: 
categories: ['Vue', 'JavaScript']
---


VueComponent間で**再利用可能な部品**を実装するための機能が**[mixin](https://jp.vuejs.org/v2/guide/mixins.html){:target="_blank"}**です。mixinを使った共通化の例はよく見かけますし、私もしばしばやってきました。ただ、どうも自分の実装方法だと後々不便になったり見通しが悪かったりと、使い勝手の悪いものになってしまうことが多かったです。

そこで今回は自分の過去の実装例を見返しながら、なぜ失敗したのか、mixinをどうを使うべきかについて、現時点の考えをまとめてみます。

<div class="note">
<p>この記事で紹介する失敗例は、<b>私の関わるプロダクトにおいて</b>デメリットの方が大きかった実装例です。</p>

便宜上「アンチパターン」「失敗例」といった表現をしていますが、あくまで<b>個人的にやりたくないパターン</b>程度の意味合いです。
</div>

* TOC
{:toc}



### 失敗例1. Template Methodパターン意識したmixin

Classの親子関係のように、実装が必須のmethodsを定義したmixinを継承する、またはOverrideすることを想定した実装です(既に失敗しそうな匂いがしますね…)。

以下のサンプルコードは、とある1画面を表現する MainPageContainer.vue と、どの画面にも必要な共通処理を抜き出した pageContainerMixin.js です。

**pageContainerMixin.js**
```js
export default {
  created() {
    document.title = this.getTitle();
  },
  mounted() {
    this.sendPageview();
  },
  methods: {
    getTitle() {
      throw new Error('You must override this function.');
    },
    sendPageview() {
      ga('send', 'pageview');
    },
  }
}
```

<p></p>

**MainPageContainer.vue**
```html
<template>
  <!-- 省略 -->
</template>

<script>
import pageContainerMixin from './pageContainerMixin';

export default {
  mixins: [ pageContainerMixin ],
  methods: {
    getTitle() {
      return 'メインページ';
    }
  }
}
</script>
```

<p></p>

mixinの中にはOverrideして使われることを想定した`getTitle`関数が実装されていますね。**Overrideされなかった場合に例外を投げて**教えてくれます。

また、mixinの中ではライフサイクルメソッドから`sendPageview`関数などを暗黙的に呼び出していて、その処理の中身を変えたいときはOverrideし派生させる仕組みにもなっています。

#### <i class="fas fa-exclamation-triangle"></i> 暗黙的挙動の危うさ

**Containerに必須の処理をmixinに閉じ込め暗黙的に実行させた**ことで、チームメンバーが簡単に新規Containerを実装できるようになったと当初は満足していました。

しかしアプリケーションが大きくなりContainer毎の独自の仕様が必要になったとき、またはメンバーが新規参入してきたとき、暗黙的に実行される処理の中身やそのOverride方法を読み解く必要性が出てきました。言い換えれば、「ちゃんと読み解かないとバグを生みやすい箇所」に化けた、ということになります。

Vueなどのように知識が一般化されたフレームワークの暗黙的挙動ならまだしも、こういった**「独自の暗黙的挙動」は負担になりやすい**ので注意が必要です。

#### <i class="fas fa-exclamation-triangle"></i> OverrideではなくMergeしているだけ

また、この仕組みはOverrideを前提としていますが、mixinがやっていることは単なるオブジェクトのMergeです(Overrideではなく！)。擬似的にOverrideに見せていますが、これにはいろいろな罠が潜んでいます。

**Overrideする要素の型を束縛できない**

* mixinでは`string`を返す関数が、Override後は`Promise`を返す関数になっている、なんて実装もできてしまう
* このような問題をコンパイラやIDEでチェックできない
* mixin側の関数を変更しても、そのOverride箇所を機械的に見つけられない
* 型を束縛しないならmixinで定義する必要がない(関数名を定義しているだけで、引数も戻り値もなんでもアリになってしまう)

**マージストラテジが変更される可能性がある**

* マージストラテジが変更されるとOverrideされなくなる可能性がある
* マージストラテジ変更により影響の出る箇所をコンパイラで見つけられない
* マージストラテジが違う箇所を理解している必要がある(createdはOverrideされない等)


#### <i class="fas fa-exclamation-triangle"></i> Classの継承とmixinは本質的に違う

そもそも抽象Classを定義したりClass継承したりすることは「共通化」や「再利用」が目的ではありませんね。**Class継承の目的は「基底と派生」**にあり、これらは密結合な関係であり、取り回ししやすい再利用性の高いもの(つまり疎結合なもの)をつくろうというmixinの思想と相反するわけですね。

そんなわけで今では、mixinでTemplate Methodパターンを実現しようという発想がそもそもアンチパターンだったのだと思っています。反省。


### 失敗例2. Decoratorパターンを意識したmixin

継承(のような)関係でmixinを使うことに危機感を覚えて以後は、もっとシンプルに**依存関係の少ない単発の機能を付与する**mixinを、以下の2つのルールに基づいて実装していきました。

* JavaなどのInterfaceにあるように「〇〇able」という命名をする
* 他のモジュールに依存しない(importしない)

以下は、PC版Twitterのフォロワー一覧画面のように、ユーザープロフィールがカード型の一覧で並ぶ画面のサンプルコードです。画面内で使われるカードComponentの ProfileCard.vue と、もっと読むボタン等などでよく見る「開閉させる機能」を提供する expandable.js というmixinの実装です。

**expandable.js**
```js
export default {
  data() {
    return {
      isExpanded: false,
    }
  },
  methods: {
    toggleExpand() {
      this.isExpanded = !this.isExpanded;
    }
  }
}
```

<p></p>

**ProfileCard.vue**
{% raw %}
```html
<template>
  <div>
    <div v-show="!isExpanded"><!-- プロフィールの概要 --></div>
    <div v-show="isExpanded"><!-- プロフィールの詳細 --></div>
    <button @click="toggleExpand">{{ buttonLabel }}</button> 
  <div>
</template>

<script>
import expandable from './expandable';

export default {
  mixins: [ expandable ],
  computed: {
    buttonLabel() {
      return this.isExpanded ? '折りたたむ' : 'もっと見る';
    }
  }
}
</script>
```
{% endraw %}

<p></p>



expandableは何にも依存せず、シンプルに「開閉ステータス」と「開閉させる関数」だけを持っています。名前からもその機能が提供されることが予測できますね。Component側も、(正確にはDecoratorパターンとは違いますが)mixinで柔軟かつ簡潔に機能を付け外しできていることがわかります。

#### <i class="fas fa-exclamation-triangle"></i> 名前競合にまつわる問題

mixinを使う以上当たり前の話で、この手法に限った問題ではないのですが、名前の競合が起きる点には注意しなければなりません。mixin一つ一つをシンプルに実装しているだけに、dataやmethodsの命名もシンプルになりがちで競合が起きやすくなっているからです。

それを回避しようとすると、わざとらしく被らない命名になったりします。失敗例1ではあえて同じ命名にしてOverrideしていましたが、今度は名前が被らないように必死ですね…。

結果的に、せっかく**mixinでコードを分離しているのに関心は分離されず**、常にmixinのことを念頭においてComponentを実装することになります。


#### <i class="fas fa-exclamation-triangle"></i> 実はComponentに依存している

こちらもmixinを使う以上当たり前の話ですが、mixinの中で使われる`this`はComponentに依存します。

{% raw %}
```js
// share機能を実現する sharable.js

export default {
  computed: {

    // Component側でshareTextとshareUrlが定義されることを期待した実装の例
    shareUrl() {
      return `https://example.com/share?text=${this.shareText}&url=${this.shareUrl}`;
    }
  },
  methods: {
    share() {
      // 省略
    }
  }
}
```
{% endraw %}
ちょっと雑な例ですが、外部サービスのintentを利用したshare機能を実現するmixinの実装例です。shareする文言やURLをComponent側で定義してもらう想定で実装しています。この例はかなり極端ですが、mixinがComponentに依存する可能性がある(危険なコードが生まれる仕組みがある)ことがわかります。

#### <i class="fas fa-exclamation-triangle"></i> Componentのソースが読みにくくなることがある

これは問題と言うには大げさかもしれませんし、やはり当たり前な話なのですが、mixinを使うと**見えないところで**Componentの`this`にプロパティが増えていくことになります。  
Componentのソースを読んでいて「この`this.〇〇`はどこに実装されているの？」と思ったことありませんか？ mixinが増えるとこの状況が増えるわけですね。

mixin以外に、Vuexの`mapState`等でも`this`にプロパティを生やしていくので、**VueComponentは見えないところでプロパティが増えがち**です。となるとmixinは少ないほうがソースの読みやすさを保てそうですよね。

まとめると、失敗例2のほうはmixinの使い方を根本的に間違えていたわけではなさそうですが、mixinが持つデメリットや懸念点に多く直面した例でした。このあたりから、mixinの利用は最低限にしようと感じるようになります😌




### ViewModelにおける再利用性とは

ここまでで「mixinの利用は必要最低限に抑える」方針が良さそうだと分かりますが、「必要最低限」とはどの程度なのでしょうか。言い換えると、**VueComponentにおいて共通部品の再利用がどの程度必要か**ということですね。

Vueアプリケーションの背景にあるMVVMの設計の観点から再利用性について考えてみます。「[Vue+VuexでMVVMなWebApplicationを設計するときに考えたいこと]({% post_url /blog/2017-08-29-1 %}){:target="_blank"}」の記事で紹介しているように、VueComponent = ViewModelと捉え、
ViewModelにおけるロジックの再利用性に着目します。

ViewModelが持つロジックは大まかに言うと「Presentationロジック」です。ViewModelはViewと1対1で結びつくので、対応するViewのための、表示用のデータの成形、ローカルStateの管理。



### mixinの代替案

- Util, Service, Helper
- Vuexのgetter
- slot

