---
title: シェルスクリプトを書くときに気をつけていること集
outline: google公式のShell Style Guideの紹介と、その中で特に自分が気をつけていることを書き出しました。ビルドやデプロイのスクリプトを用意するときなどにこれを基に自己レビューしています。
categories: ['shell']
---

シェルスクリプトはWebアプリケーションの開発において必須スキルというわけではないのかもしれませんが、ビルドやデプロイのスクリプトを書くときに結構役立ったりします。ただ、たまにしか書かないこともあり、適切なスクリプトが書けているか不安になることがあります。

そんなときに頼りにしているのがGoogle製の**[Shell Style Guide](https://google.github.io/styleguide/shell.xml){:target="_blank"}**(以下「ガイド」)です。とりあえず最低限のお作法としてこれに従いつつ、要所要所をアレンジして実装しています。

今回は中でも特に気をつけている部分をピックアップしてチェック表代わりにしてみようと思います。


### どのshellを使うか

**原則bashを使う。shebangは`#!/bin/bash`とする**

特段な理由がなければbashを利用するようにします。日頃使っているコマンドの中には、実はPOSIX準拠ではなくbash等で拡張されたものも存在します。個々のコマンドがPOSIX準拠かどうか、またスクリプト本体がどのshellでの実行を想定しているかを明記するためにも、shebangには`#!/bin/bash`と書くようにします。

私の場合、スクリプトを手元とCircleCIの両方から実行する、というケースがよくあります。CiecleCIの仮想環境はubuntuでデフォルトのshellがdashですので、手元で動いたスクリプトがCI上では動かない…といったことを避けるためにも原則bashとしています。

### いつshellを使うか

**小さなツール・ユーティリティとして使う**

### 拡張子

- **直接実行可能なものは拡張子をつけない**
- **ライブラリとしてのスクリプトは拡張子必須**

直接実行する場面では「どの言語で書かれているか」を意識する必要がないためです。逆にライブラリとして利用されるスクリプトは意識する必要がありますよね。「直接実行可能か」をひと目で判断しやすくするためにも拡張子の有無に気を配るようにしています。

### エラーメッセージ

**全てのエラーメッセージはSTDERR(標準エラー出力)へ書き出す**

通常の状態とエラー状態を識別しやすくするためですね。

```shell
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit "${E_DID_NOTHING}"
fi
```
リダイレクト`>`とファイルディスクリプタ`&2`を使ってSTDERRに出力するサンプルコードです。


### フォーマット

- **インデントはスペース2つ**
- **1行は80文字まで**
- **パイプラインが3つ以上続くときは改行する**
- **ループ文やif文では、同じ行に`; do`や`; then`を書く**
- **case文では、改行して`;;`を書く**

特にこだわりはないのでガイドに従います。


### 変数展開

**`"$var"`より`${var}`を使う**

ガイドには「既存の実装に揃えることを優先すること」とも記載されていますが、既存の実装がないのでこのルールに従っています。

### コマンド置換

**`` `command` ``より`$(command)`を使う**

`$(command)`は入れ子にできる利点があります。

```shell
# This is preferred:
var="$(command "$(command1)")"

# This is not:
var="`command \`command1\``"
```

### test, [, [[

**`[[ ... ]]`を利用する**

`[[ ... ]]`はPOSIX準拠ではないので注意が必要ですが、testコマンド等に比べて機能が拡張されています。とくに変数展開に関する問題が減るので、原則利用するようにしています。

### empty check

**極力`-z`, `-n`を利用する**

空文字列のチェックなどのempty checkをするときは`-z`(zero)や`-n`(non-zero)を利用します。

```shell
if [[ -n "${my_var}" ]]; then
  do_something
fi
```


### ファイル名のワイルドカード

**ワイルドカードを利用するときは`*`ではなく`./*`とする**

ワイルドカードを利用するときはpathを明示します。ミスを防ぐことと可読性を高めることが目的だと思います。


### whileとパイプライン

**パイプでwhileにつなぐ代わりに、forループまたはプロセス置換を使う**

whileを使うと暗黙的にsubshell(子プロセス)が生成されます。その結果、子プロセスから親プロセスの変数にアクセスできなかったり、何か問題が起きたときに追跡しにくくなったりします。

以下のコードは、subshellから親の変数にアクセスできない例です。

```shell
last_line='NULL'
your_command | while read line; do
  last_line="${line}" # 親で定義したlast_lineへアクセスできない
done

echo "${last_line}"   # そのため親のlast_lineは更新されておらず、'NULL'が出力される
```

<p></p>

forループでの代替例です。

```shell
total=0
# Only do this if there are no spaces in return values.
for value in $(your_command); do
  total+="${value}"
done
```

<p></p>

次にプロセス置換の例です。プロセス置換もsubshellを使いますが、whileと違い明示的であるため幾分か良いです。ちなみにプロセス置換はPOSIX準拠ではありませんのでご注意を。

```shell
total=0
last_file=
while read count filename; do
  total+="${count}"
  last_file="${filename}"
done < <(your_command | uniq -c)
```

### 関数

- **スネークケースで書く**
- **パッケージの関数は`::`で区切る**

```shell
# Single function
my_func() {
  ...
}

# Part of a package
mypackage::my_func() {
  ...
}
```

### 命名規則

- **変数やファイル名はスネークケース**
- **定数は大文字のスネークケース**
- **定数や環境変数は`readonly`または`declare`する**
- **関数内で使う変数は`local`をつける**

```shell

```
