---
title: Babel7.x時代のpolyfillの設定方法とuseBuiltInsの仕組み
outline: 
categories: ['JavaScript', 'Babel', 'Environment']
---


ES2015+で実装するためにBabelのpolyfillを利用する場面は多いと思いますが、Babel6.xまでと7.xではその導入方法が変わっているので注意が必要です)。今回はBabel7.xでの用途別polyfillの設定の仕方と、キモとなる`useBuiltIns`オプションの挙動についてまとめてみます(執筆時点でのBabelのバージョンは**7.1.0**です)。

なお、6.xまでの設定方法は「[Babelの設定を見直すための逆引きガイド]({% post_url /blog/2018-03-19-1 %}){:target="_blank"}」にまとめてあります(polyfillのことだけでなく、Babelとは何か、どのように利用するのか、といったことも併せてまとめてありますので良ければご参考にどうぞ)。




### 用途別polyfillの入れ方


polyfillの入れ方には大きく3種類あります。

| 用途                                   | 方法                                                               |
|----------------------------------------|--------------------------------------------------------------------|
| 必要なpolyfillだけ入れる               | `useBuiltIns`オプション **usage** を使う                           |
| 全てのpolyfillを入れる                 | [@babel/polyfill](https://babeljs.io/docs/en/babel-polyfill){:target="_blank"}をimport/requireする                                            |
| グローバル汚染せずにpolyfillを適用する | [@babel/runtime](https://babeljs.io/docs/en/babel-runtime){:target="_blank"}と<br>[@babel/plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime){:target="_blank"}を使う |

<p></p>

大幅に変更されたのが`useBuiltIns`オプションの挙動です。6.xではまずbabel-polyfillを入れた上で「それをどのようにcore-jsに置き換えるか」をuseBuiltInsオプションで指定する形でした。
対して7.xでは`useBuiltIns`オプションに応じて@babel/polyfillを入れたり入れなかったりします。

ではそれぞれの方法の詳細を見ていきます。


#### 1. 必要なpolyfillだけを入れる方法

**[@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env){:target="_blank"}の`useBuiltIns`オプションを`usage`とする**と、@babel/polyfillをソース内でimportせずとも必要なpolyfillだけを自動で選別して入れてくれます。ただし、**@babel/polyfillをnpm installしておく**必要はあります。


**@babel/polyfill, @babel/preset-envをインストールする**
```shell
$ npm install -D @babel/preset-env
$ npm install -S @babel/polyfill
```

<p></p>

**.babelrcを記述する**
```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "usage"
      }
    ]
  ]
}
```

<p></p>

この方法はメリットが大きいですが、公式ドキュメントに**experimental**と記されている点が要注意です。  
polyfillが必要な実装例を[いくつか試してみた](https://github.com/aloerina01/til/tree/master/daily/20181128){:target="_blank"}ところ、静的解析してimportするpolyfillを特定している雰囲気でした。分かりやすかった例をピックアップしてみます。

```js
obj = {};
let letObj = {};
const constObj = {};

obj['includes'];      // array.includes と string.includes のpolyfillが入る
letObj['includes'];   // polyfillが入らない
constObj['includes']; // polyfillが入らない
```
この例では、`let`も`const`も使わずに定義された`obj`に対して`includes`を呼び出すと、Stringの`includes`とArrayの`includes`のpolyfillが読み込まれました。言い換えれば、スコープが明確な`letObj`と`constObj`に対しては、その型がArrayでもStringでもないと判定されているわけですね。

賢いなあと関心したものの、production利用はちょっと怖い…というのが今の気持ちです。

ちなみに「importされているか怪しいpolyfillを個別に手動でimportする」案も考えたのですが、手動で入れたものとの重複判定はしてくれないようでしたので、この案もダメそうですね😳


#### 2. 全てのpolyfillを入れる方法

Babel6.xまでと同じように**[@babel/polyfill](https://babeljs.io/docs/en/babel-polyfill){:target="_blank"}をimport/requireする**方法です。合わせて`useBuiltIns`オプションに`entry`か`false(default)`を指定することができます。

**@babel/polyfill, @babel/preset-envをインストールする**

```shell
$ npm install -D @babel/preset-env
$ npm install -S @babel/polyfill
```

<p></p>

**エントリーポイントでpolyfillを読み込む**

```js
// index.js

import '@babel/polyfill';

Promise.resolve();  // polyfillが必要な実装
```

<p></p>

**.babelrcを記述する**
```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "entry"  // 任意
      }
    ]
  ]
}
```

`useBuiltIns`に`entry`を指定すると、@babel/polyfillのimportを**生のcore-jsのimportに置換してくれます**。また、今まで通り同じpolyfillを複数回importするのはNGなのでその点もお忘れなく。


#### 3. グローバル汚染せずにpolyfillを適用する方法

Babel6.xまででは`babel-plugin-transform-runtime`を使っていましたが、7.xからは2つのmoduleを使います。

* [@babel/runtime](https://babeljs.io/docs/en/babel-runtime){:target="_blank"} ... ソースにバンドルされるpolyfill本体
* [@babel/plugin-transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime){:target="_blank"} ... polyfillが必要な箇所を@babel/runtimeに置き換えてくれるもの

**@babel/runtime, @babel/plugin-transform-runtimeをインストールする**

```shell
$ npm install -S @babel/runtime
$ npm install -D @babel/plugin-transform-runtime
```

<p></p>

**.babelrcを記述する**

```js
{
  "plugins": ["@babel/plugin-transform-runtime"]
}
```

<p></p>

利用の際は、Babel6.xまでと同様に**インスタンスメソッドは使えない**ということに注意する必要があります。


### useBuiltInsのコードリーディング

ここからは余談です。  
useBuiltInsオプションがどのように実装されているか気になったので、軽くコードリーディングしてみました。そのときのメモをまとめておきます。

##### [<i class="fas fa-check"></i> babel-preset-env/src/index.js#L285](https://github.com/babel/babel/blob/59e9c6322baf6cbd1952c40ce5dd0b2ea7802712/packages/babel-preset-env/src/index.js#L285){:target="_blank"}

`useBuiltIns`の値に応じて利用するプラグインを分岐しています。

* entry設定時 [babel/use-built-ins-entry-plugin.js](https://github.com/babel/babel/blob/master/packages/babel-preset-env/src/use-built-ins-entry-plugin.js){:target="_blank"}
* usage設定時 [babel/use-built-ins-plugin.js](https://github.com/babel/babel/blob/master/packages/babel-preset-env/src/use-built-ins-plugin.js){:target="_blank"}

これらのプラグインは、どちらも以下のようなPluginオブジェクトを返す関数を実装しています。

```js
export default function({ types: t }: { types: Object }): Plugin;

type Plugin = {
  visitor: Object,  // polyfill の import を解決するための処理群
  pre: Function,   // メイン処理前に実行すること
  name: string     // pluginの識別子のようなもの
}
```
Plugin.visitorが大きく差が出る部分ですね。


##### [<i class="fas fa-check"></i> babel-preset-env/src/use-built-ins-entry-plugin.js#L31](https://github.com/babel/babel/blob/master/packages/babel-preset-env/src/use-built-ins-entry-plugin.js#L31){:target="_blank"}

Plugin.visitorに渡される`isPolyfillImport`オブジェクトを見ると、`ImportDeclaration`関数に「@babel/polyfillがimportされてるならフラグをたてて、それを必要なmoduleのimportにreplaceしていく」といった実装があります。

##### [<i class="fas fa-check"></i> babel-preset-env/src/use-built-ins-plugin.js#L68](https://github.com/babel/babel/blob/master/packages/babel-preset-env/src/use-built-ins-plugin.js#L68){:target="_blank"}





