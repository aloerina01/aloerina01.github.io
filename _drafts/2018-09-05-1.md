---
title: React+Fluxを正しく使いこなすための設計入門
outline: Action、Store、Dispatcher…よく聞くFluxの登場人物ですが、これらの責務とは何か。どう実装するのが良いのか。「なんとなく理解している」から「ちゃんと理解している」にステップアップするために整理したことを書き起こしました。
categories: ['React', 'Flux']
---

Reactの良さを活かしやすいFluxは、Webアプリケーションの設計手法としてずいぶん馴染みのあるものになったように感じます。私もFluxを取り入れた開発を2年近く経験し、知見も溜まり、使い慣れたような気持ちでいました。

が、使い始めた頃はもちろん、今でも何となく分かったつもりでいる部分があったり、複雑な実装が必要な場面で悩むことがあったりします。「Fluxはダメだ！うまく実現できない！」と放り出したくなるときもありますが、そんなときこそ基礎への立ち返る機会。  
そんなわけでFluxに再入門し、**Fluxとは何なのか、どう実装するのが適切なのか**を公式ドキュメントに則って整理してみようと思います。

* TOC
{:toc}

### Fluxとは

Fluxとは、**クライアントサイドのデータフローの設計パターン**です。

![flux data flow](/assets/2018-09-14-1-flux.png)
<small>[In Depth Overview - Flux](https://facebook.github.io/flux/docs/in-depth-overview.html#content){:target="_blank"}より</small>

Fluxの代名詞的なこの図でも示されている通り、Fluxは**データの流れを一方向に強制します**。そして一方向に流れるデータを受け取る/送る4つの登場人物(Action, Dispatcher, Store, View)が**どのようにデータを扱うかを定義する**ことで、アプリケーション内の見通しを良く保つ設計となっています。

この一方向データフローは**イベント駆動**で実現されます。詳細は後述しますが簡単に流れをまとめると、

* **Action**と呼ばれるイベントとデータのかたまりが
* **Dispatcher**と呼ばれるイベントハブに集約され
* Dispatcherに登録されたコールバックによって**Store**の状態を更新し
* そしてStoreの変更を検知した**View**が自身を更新します。

このように、Fluxは**一方向データフロー**と**イベント駆動**を根幹とする設計手法となっています。これを念頭に置いた上で、Fluxの4つの役割がどういうものなのか考えていきます。



### Dispather

Dispatcherはアプリケーション全体で唯一のイベントハブです。イベント駆動であるFluxの根幹ですが、仕組みはシンプルで2つの要件を満たせば成立します。

#### 要件1 イベントが発生したらすべてのコールバックを実行すること

Dispatcherは、`addEventListener`のように「特定のイベントに特定のコールバックを紐づける」のではなく、**何らかのイベントがdispatchされたら登録されている全てのコールバックを実行します**。その際、コールバックには**ペイロード**と呼ばれる「イベントに関する情報を持つオブジェクト」を引数として渡します。ここまでがDispatcherの役割です。  

後述しますが、ペイロードに応じてStoreの中身をどう更新するか(または更新しないか)は、コールバック側で判断することになります。

ここまでをまとめると、Dispatcherとは「コールバックを登録し、イベントがdispatchされたら登録されたすべてのコールバックにペイロードを渡し実行する」ものであると言えます。コードで表現すると以下のようになります。

```js
class Dispatcher {
  constructor() {
    this.callbacks = [];
  }
  register(callback) {
    this.callbacks.push(callback);
  }
  dispatch(payload) {
    this.callbacks.forEach(callback => callback(payload));
  }
}
```

#### 要件2 コールバックの実行順序を制御できること

Storeを更新する際、実行順序を意識しなければならない場面もあると思います。例えば「ユーザーの設定を更新して、それに応じて表示する情報を更新する」といったケースですね。これに対応することがDispatcherのもう一つの要件です。つまり**コールバックの実行順序を制御する**ことです。

Fluxの設計手法を実現するための最小限のライブラリである[Flux Utils](http://facebook.github.io/flux/docs/flux-utils.html#content){:target="_blank"}で実例を確認してみます。Flux Utilsに実装されている[Dispatcher.js](https://github.com/facebook/flux/blob/master/src/Dispatcher.js){:target="_blank"}には`waitFor`という関数が定義されていて、これがコールバックの実行順序を制御しています。

`waitFor`関数は、コールバックの中から呼び出すもので、「あのコールバックの実行を待ってから、自身を実行する」という制御をすることができます。

~~~js
const callback1 = (payload) => {
  return doHoge();
}
// callbackを登録すると、識別子が発行されます
const callbackId1 = dispatcher.register(callback1);

const callback2 = (payload) => {
  // どのcallbackの実行を待つかを指定します
  // 複数のcallbackを待てるように、waitForの引数はArrayになっています
  dispatcher.waitFor([callbackId1]);
  return doFuga();
}
dispatcher.register(callback2);
~~~

1. dispatcherにコールバックを登録すると、コールバックの識別子が発行されます
2. コールバック内で`waitFor`を呼び出し、引数に実行を待ちたい識別子を渡します
3. あとは同期的に処理を書くだけでOKです


#### コールバックは何をするのか？







### Action

Actionは、そのアプリケーション内でどんなユーザーオペレーションが起きるのか(ログインする、登録する、等)を定義するものです。言い換えると**ユースケースを定義するもの**です。  

実装例を見てみます。TODOアプリにおいて、「TODOを追加する」アクションの実装例です。

```js
{
  type: 'ADD_TODO',
  text: 'hoge'
}
```

Actionはシンプルなオブジェクトで実装され、ユースケースを表す`type`と、その実行に必要な値を持ちます。実行に必要な値は**Payload**と呼ばれ、上の例でいうと`text: 'hoge'`の部分がPayloadです。Payloadはあってもなくてもよく、また複数あっても問題ありません。このActipnがDispatcherに渡されることで、アプリケーションのロジックが実行され、最終的にViewに反映されることとなります。

実際のコード内では、Action(オブジェクト)を生成しDispatcherに送るまでの一連の処理を行うヘルパーメソッドを実装するケースが多く、このヘルパーメソッドをActionCreatorと呼びます。

```js
const addTodo = (text) => {
  const action = {
    type: 'ADD_TODO',
    text: text
  };
  Dispatcher.dispatch(action);
};
```

また、`type`を定数化し`ActionTypes`として1箇所にまとめておく実装例もよく見かけます。

```js
// path/to/ActionTypes.js
export default ActionTypes = {
  ADD_TODO: 'ADD_TODO'
}

// path/to/ActionCreators.js
export const addTodo = (text) => {
  const action = {
    type: ActionTypes.ADD_TODO,
    text: text
  };
  Dispatcher.dispatch(action);
}
```

https://github.com/redux-utilities/flux-standard-action

ActionやActionCreatorがあると、開発者はこれらを見るだけでアプリケーションが持つユースケースを一覧することができます。


アプリケーションに起きうるユースケースを表現する
ユースケースとは「ユーザがシステムを通じてする操作」(最適でわかりやすい表現を考える)
Actionは「このアプリケーションでどんなオペレーション・状態変化が起きるのか」を定義・列挙するもの
FluxはMV*の複雑さへの解として生まれたので、何が起きるかが一目瞭然になるというのは意味があること
actionはオブジェクト
かならずtypeを持つ
処理に必要なデータとtypeをセットにしてActionと呼ぶ
このデータをpayloadと呼ぶ

### Store

Storeの定義

StateとLogicを持つ
実はロジックもここなのよ。ここで言うロジックはDispatcherに登録するcallbackのことであって、これはイコールビジネスロジックでもある
アプリケーションのStateを管理するもの、というのが名目上の定義
これはMV*のModelが持つようなAppStateも含むし、複数のViewにまたがるViewStateも含む(からややこしい)
ViewStateも含むというより、含ませざるを得ない
setterは持たず、getterのみ
シングルトンのStore
pure functionなreduce




### View




### 余談

#### Fluxの利点

Fluxを利用することで得られるメリットは大きく2つあります。

一つは(特定の)複雑さに強く、アプリケーションが大きくなっても破綻しにくいこと。  
Fluxは現代のWebアプリケーションでよくある**UIと複雑なデータ構造を持つアプリケーション**を想定して作られています。そのようなアプリケーションに必要な実装をAction,Dispatcher,Store,Viewという4つの役割に分離し、それぞれに**明確な責務**と**データの取り扱い方**を与えています(詳細は後述します)。  
この4つの役割を正しく理解し実装に落とし込むことで、アプリケーションが肥大化しても互いに疎結合で、一部の修正が他に影響せず、責務が分離された堅牢なアプリケーションを維持することができます。

もう一つは誰が実装しても同じような実装になり、破綻しにくいこと。  
上述の通り、アプリケーションに必要な責務を明確に4つに分けているため、「状態をどこで管理するべきか」「ビジネスロジックをどこに書くべきか」といったような実装の差(もしくは迷い)が生じにくくなります。実際にReact+FluxのアプリケーションとVue+MVVMのアプリケーションをチームで実装してみたときに、前者のほうが「何をどこに書くか」という観点での悩みは少なかったように感じます。  

※ FluxとMVVMのどちらが優れているかという話ではなく、「何をどこに書くか」という観点での認識のズレが起きにくいのがFluxだった、というだけの話です。認識のズレが起きにくいというのは規約が固く明確であるということで、言い換えればMVVMのほうが柔軟性が高く状況に応じて工夫を施しやすいという見方もできると思います。


#### MV*の歴史から見るFlux

MVCではある処理をする際、Controllerが処理の窓口となり、「まずViewにローディングアイコンを出し、次にモデルのデータを更新し、それをViewに反映し…」と宣言的に記述していくことになります。これだと規模が大きくなるにつれ複雑になっていったり、フロントの要件とは相性が悪かったりするので、一部をイベント駆動にしたりデータの持ち方を変えてみたりと試行錯誤した結果が、MV*なのだと認識しています。
