---
title: React+Fluxで良きWebアプリを設計するためのFlux入門
outline: Action、Store、Dispatcher…よく聞くFluxの登場人物ですが、これらの責務とは何か。どう実装するのが良いのか。「なんとなく理解している」から「ちゃんと理解している」にステップアップするために整理したことを書き起こしました。
categories: ['React', 'Flux']
---

Reactの良さを活かしやすいFluxは、Webアプリケーションの設計手法としてずいぶん馴染みのあるものになったように感じます。私もFluxを取り入れた開発を2年近く経験し、知見も溜まり、使い慣れたような気持ちでいました。

が、使い始めた頃はもちろん、今でも何となく分かったつもりでいる部分があったり、複雑な実装が必要な場面で悩むことがあったりします。「Fluxはダメだ！うまく実現できない！」と投げ出したくなるときもありますが、そんなときこそ基礎へ立ち返る機会。  
そんなわけでFluxに再入門し、**Fluxとは何なのか、どう実装するのが適切なのか**を公式ドキュメントに則って整理してみようと思います。

* TOC
{:toc}

### Fluxとは

Fluxとは、**クライアントサイドのデータフローの設計パターン**です。

![flux data flow](/assets/2018-09-14-1-flux.png)
<small>[In Depth Overview - Flux](https://facebook.github.io/flux/docs/in-depth-overview.html#content){:target="_blank"}より</small>

Fluxの代名詞的なこの図でも示されている通り、Fluxは**データの流れを一方向に強制します**。そして一方向に流れるデータを受け取る/送る4つの登場人物(Action, Dispatcher, Store, View)が**どのようにデータを扱うかを定義する**ことで、アプリケーション内の見通しを良く保つ設計となっています。

この一方向データフローは**イベント駆動**で実現されます。詳細は後述しますが簡単に流れをまとめると、

* ボタンクリックなどをトリガーにして
* **Action**と呼ばれるイベントとデータのかたまりが
* **Dispatcher**と呼ばれるイベントハブに集約され
* Dispatcherに登録されたCallbackによって**Store**の状態を更新し
* そしてStoreの変更を検知した**View**が自身を更新します。

このように、Fluxは**一方向データフロー**と**イベント駆動**を根幹とする設計手法となっています。これを念頭に置いた上で、Fluxの4つの役割がどういうものなのか考えていきます。



### Dispatcher

Dispatcherはアプリケーション全体で唯一のイベントハブです。イベント駆動であるFluxのコアであり、Fluxのデータフローを支えるための2つの要件を満たす必要があります。

#### 要件1 イベントが発生したらすべてのCallbackを実行すること

Dispatcherは、`addEventListener`のように「特定のイベントに特定のCallbackを紐づける」のではなく、**何らかのイベントがdispatchされたら登録されている全てのCallbackを実行します**。その際、Callbackには**Payload**と呼ばれる「イベントに関する情報を持つオブジェクト」を引数として渡します。ここまでがDispatcherの役割です。  

Payloadに応じてStoreの中身をどう更新するか(または更新しないか)は、Callback側で判断することになります。

ここまでをまとめると、Dispatcherとは「Callbackを登録し、イベントがdispatchされたら登録されたすべてのCallbackにPayloadを渡し実行する」ものであると言えます。コードで表現すると以下のようになります。

```JavaScript
class Dispatcher {
  constructor() {
    this.callbacks = [];
  }
  register(callback) {
    this.callbacks.push(callback);
  }
  dispatch(payload) {
    this.callbacks.forEach(callback => callback(payload));
  }
}

const instance = new Dispatcher();
export default instance;
```

余談ですが、Dispatcherは「アプリケーション全体で唯一のイベントハブ」なのでシングルトンで実装されている例が多いような気がします。

#### 要件2 Callbackの実行順序を制御できること

Storeを更新する際、実行順序を意識しなければならない場面もあると思います。例えば「ユーザーの設定を更新して、それに応じて表示する情報を更新する」といったケースですね。これに対応することがDispatcherのもう一つの要件です。つまり**Callbackの実行順序を制御する**ことです。

Fluxの設計手法を実現するための最小限のライブラリである[Flux Utils](http://facebook.github.io/flux/docs/flux-utils.html#content){:target="_blank"}で実例を確認してみます。Flux Utilsに実装されている[Dispatcher.js](https://github.com/facebook/flux/blob/master/src/Dispatcher.js){:target="_blank"}には`waitFor`という関数が定義されていて、これがCallbackの実行順序を制御しています。

`waitFor`関数はCallbackの中から呼び出すもので、「あのCallbackの実行を待ってから自身を実行する」という制御をすることができます。

```JavaScript
const callback1 = (payload) => {
  UserSettingStore.hoge = payload.hoge;
}
const callbackId1 = dispatcher.register(callback1);  // callbackを登録すると、識別子が発行されます

const callback2 = (payload) => {
  dispatcher.waitFor([callbackId1]);  // UsdrSettingStoreの更新を待ちます
  const userSetting = UserSettingStore.getState(); // UserSettingStoreの更新後に最新の状態を取得します
  // do Something
}
dispatcher.register(callback2);
```

1. DispatcherにCallbackを登録すると、Callbackの識別子が発行されます
2. Callback内で`waitFor`を呼び出し、引数に実行を待ちたい識別子を渡します
3. あとは同期的に処理を書くだけでOKです

この`waitFor`関数は実装の一例ですが、このようにCallbackの実行順序を管理できる仕組みを持っておくことが必要です。



### Action

#### Actionに必要なたった2つのこと

Actionは、そのアプリケーション内でどんなユーザーオペレーションが起きるのか(ログインする、登録する、等)を定義するものです。言い換えると**ユースケースを定義するもの**です。Actionの要件は以下の2つです。

1. プレーンなオブジェクトであること
2. ユースケースを表す`type`プロパティを持っていること

とてもシンプルですね。ちなみにActionオブジェクト内に定義される`type`は一般的に**ActionType**と呼ばれびます。

また、Actionには`type`プロパティ以外に、ユースケースを実行するために必要な値を持たせることもできます。以下のコードはTODOアプリの「TODOを追加する」アクションの実装例です。

```JavaScript
const todoAction = {
  type: 'ADD_TODO',  // ActionType
  text: 'hoge'       // 新しく追加するTODOの文字列
}

dispatcher.dispatch(todoAction);  // actionをdispatcherにわたす
```

このActionと呼ばれるオブジェクトがDispatcherに渡されることがFluxのデータフローの起点になります。

#### ActionCreator

実際のコードでは、Actionを生成しDispatcherに送るまでの一連の処理を行うヘルパーメソッドを実装するケースが多く、このヘルパーメソッドを**ActionCreator**と呼びます。

```js
import ActionTypes from './ActionTypes';
import dispatcher from './Dispatcher';

const addTodo = (text) => {
  const action = {
    type: ActionTypes.ADD_TODO,  // 定数化されたActionType
    text: text
  };
  dispatcher.dispatch(action);
};
```


#### Flux Standard Action

Flux思想のライブラリのひとつである[Redux](https://redux.js.org/){:target="_blank"}では、「Actionとはこう実装すべき」という指標を定義しています。それが[Flux Standard Action (FSA)](https://github.com/redux-utilities/flux-standard-action){:target="_blank"}です。

FSAは「読みやすさ」「使いやすさ」「シンプルさ」をコンセプトとし、上述の2つの要件に加え4つのルールを設けています。

* Actionは`payload`プロパティを持つことができる
* Actionは`error`プロパティを持つことができる
* Actionは`meta`プロパティを持つことができる
* Actionは`type`, `payload`, `error`, `meta`以外のプロパティを持ってはいけない

`type`プロパティはActionTypeのことですね。「typeは`===`を使って同じものか判定できるべきだ」と定義していますが、一般的にActionTypeは文字列で定義することがほとんどだと思うので、特に意識する必要はなさそうです。

FSAにおける`payload`プロパティは今まで説明してきた「Payload」より狭義です。先述したPayloadは「Dispatcherに渡されるもの」であり、つまりActionオブジェクトそのものを指していました。それに対してFSAのPayloadは「Actionの実行に必要な値」のみを指しています。「TODOを追加する」Actionの例でいうと、`text`部分のみがPayloadということになります。

```JavaScript
{
  type: ActionType.ADD_TODO,
  payload: {
    text: 'hoge'
  }
}
```

FSAにおける`error`プロパティは、エラーが起きたことを通知するために`true`をセットして使います。「エラーであることを正常時と同じ方法で伝達する」という点で`Promise.reject`に似ている、と説明されています。`error: true`のときは`payload`にはエラーオブジェクトを詰めるのが一般的な用法です。

FSAにおける`meta`プロパティは、`payload`に詰めるべきでないものを持つための補助的なものです。

以上がFSAのルールです。  
FSAはReduxを使う上で守るべきものですが、Redux以外の方法でFlux設計をする場合でも、Actionをどう定義すべきか迷ったときには選択肢のひとつとして検討してみるといいと思います。


### Store

#### Storeの役割

Storeは**アプリケーションのState(状態)**と、**それを操作するロジック**を持ちます。これだけ聞くとMV*のModelにも似ていますが、いくつか大きく異なる点があります。

* getterのみを持ち、setterを持たない
* setterの代わりにStoreを更新するための関数を持ち、それをDispatcherのCallbackとして登録する
* Storeが変更されたら、イベントを発火し変更をViewに伝える

```JavaScript
import ActionTypes from './ActionTypes';
import dispatcher from './Dispatcher';

class TodoStore {
  constructor() {
    this.state = {
      todo: [],
      done: []
    };
    dispatcher.register(this.update.bind(this)); // CallbackをDispatcherに登録
  }
  
  // gettetr
  getState() {
    return this.state;
  }

  // Storeが持つStateを更新するための関数
  update(action) {
    switch(action.type) {
      case ActionTypes.ADD_TODO:
        const nextState = Object.assign({}, this.state);
        nextState.todo.push(action.text);
        this.state = nextState;
      case ActionTypes.DONE_TODO:
      default:
        /* 略 */
    }
    this.emit();  // Store内のStateが更新されたらイベントを発火
  }
}
```

このように、Storeが保持する値を個別に更新する方法(Setter)は存在しません。Storeが持つ値をひとまとめの`State`とみなし、**どのような条件でどのようにStateを更新するかを定義している**関数が実装されています。Dispatcherの説明時に度々登場した「Callback」は、Storeで実装されるというわけですね。

ここまでの話をまとめると、**何らかのActionがDispatcherに渡されると、Dispatcherに登録されているすべてのCallbackが実行され、そのCallbackが各々のStoreを更新していく**ということになります。

ここまでで「どのようにViewを変更するか」の話が出ていないことからも分かるように、Viewとロジックは完全に切り離されることになります。アプリケーションの状態を変更するレイヤーでは「どのように状態を変えるか」にのみ専念すれば良く、変更後の状態に応じてViewをどのように変えるかはView側が気にかければ良いというわけです。

<div style="border-radius:10px;background-color:#f7f7f7;padding:12px 20px;margin:42px 0 48px;">

ただし、実際にはStoreがViewの状態を保持しなければならない場面も出てくると思います。つまりSoteには「アプリケーションの状態を保持するStore」と「Viewの状態を保持するStore」という2種類が出てくるということになります。  
とは言えこれは<a target="_blank" href="http://facebook.github.io/flux/">Flux公式</a>の外のお話。また別の機会に考えをまとめてみようと思います。

</div>


#### InitialStateの実装

ViewはStateを取得するためにStoreのgetterを叩きます。ただ、初期描画時にはStoreが空っぽなので、初期値を定義しておく必要があります。上の実装例では`constructor`の中で初期値を定義していますが、別の関数としてくくり出しておくのが一般的です。

```JavaScript
class TodoStore {
  getInitialState() {
    return {
      todo: [],
      done: []
    }
  }
  getState() {
    return this.state || this.getInitialState();
  }
}
```

#### Reduceの実装、そしてImmutableState

Stateを更新するCallbackの実装方法においても、一般的に良しとされているパターンがあります。それが**Reduce関数**です。Reduce関数は**現在のStateとPayloadを受け取り、新しいStateを返す純粋関数**です。

```JavaScript
class TodoStore {
  reduce(currentState, action) {
    switch(action.type) {
      case ActionTypes.ADD_TODO:
        const nextState = Object.assign({}, currentState);
        // do something
        return nextState;
      default:
        return currentState;
    }
  }
}
```

こうすることでStoreのテストがしやすかったり、データの更新ロジックの周りに副作用が起きにくかったり、`dispatcher.waitFor`などと組み合わせても煩雑にならず可読性の高い状態を維持できたり…といったことが期待されます。

Reduce関数と併せて、**StateをImmutableにする**実装パターンもよく使われます。Reduce関数以外のところで意図せずStateが書き換えられてしまうことを防ぎ、堅牢性を高める手法です。

Flux Utilsの[FluxReduceStore.js](https://github.com/facebook/flux/blob/master/src/stores/FluxReduceStore.js){:target="_blank"}は、これらのパターンを組み込んだStoreを実装するためのライブラリです。このStoreを継承したStoreを実装すると、自然に由緒正しきStoreを実装することができます(できました)。




### View

Fluxにおける「View」という役割には、実は2つの登場人物が含まれます。

* ステートを持つController-Views
* ステートを持たないViews(役割としてのViewと区別するために単数形で表現します)

Flux

#### ステートを持つController-Views



#### ステートを持たないViews

Fluxにおける「View」の基本的な役割はシンプルで、**外から状態を受け取り、テンプレートにはめ込み表示する**のみです。それを実現するのが**ステートを持たないViews**です。

ReactComponentで表現すると、**Stateを持たず、Propsを受け取るだけのComponent**です。

```JavaScript
import React from 'react';

class TodoComponent {
  render() {
    return <input type="checkbox" checked="{this.props.isDone}">{this.props.text}
  }
}

// propsに { isDone: false, text: 牛乳を買う } を受け取り、
// これらをはめ込んだチェックボックスを描画する
```

普通にReactのComponentとして実装するならこうなりますが、最近ではこの書き方は非推奨で、Stateを持たないComponentは**[Functional Component](https://reactjs.org/docs/components-and-props.html#functional-and-class-components){:target="_blank"}**を使って実装します。

```JavaScript
import React from 'react';

function TodoComponet(props) {
  return <input type="checkbox" hecked="{props.isDone}">{props.text}
} 
```
このように関数としてComponentを定義するのがFunctional Componentです。Stateを持つ必要のないComponentはこの方法で実装するのがベターです。

とは言えComponentがStateを絶対持ってはいけないというわけではなくて、表示に関する状態を


Viewの役割はMV*でも言われているように、UIとロジックの分離のため
とくにReact+Fluxでは、「UIのTemplateだけを定義していて状態を持たない、受け取ったものをはめ込んで表示するView＝ステートレスなView」
Reactではこの表現方法としてfunctional componentが最適
Viewはこの「コンポーネント」をTree上に配置して構成される
Treeの最上部にいるのがContoller-view(flux-utilだとcontainer)
ステートレスコンポーネントのルートにあり、Storeの変更を検知して、Storeの値を反映する



### 余談

#### Fluxのメリットを活かすために考えていること

Fluxを利用することで得られるメリットは大きく2つあります。

一つは(特定の)複雑さに強く、アプリケーションが大きくなっても破綻しにくいこと。  
Fluxは現代のWebアプリケーションでよくある**UIと複雑なデータ構造を持つアプリケーション**を想定して作られています。そのようなアプリケーションに必要な実装をAction,Dispatcher,Store,Viewという4つの役割に分離し、それぞれに**明確な責務**と**データの取り扱い方**を与えています(詳細は後述します)。  
この4つの役割を正しく理解し実装に落とし込むことで、アプリケーションが肥大化しても互いに疎結合で、一部の修正が他に影響せず、責務が分離された堅牢なアプリケーションを維持することができます。

もう一つは誰が実装しても同じような実装になり、破綻しにくいこと。  
上述の通り、アプリケーションに必要な責務を明確に4つに分けているため、「状態をどこで管理するべきか」「ビジネスロジックをどこに書くべきか」といったような実装の差(もしくは迷い)が生じにくくなります。実際にReact+FluxのアプリケーションとVue+MVVMのアプリケーションをチームで実装してみたときに、前者のほうが「何をどこに書くか」という観点での悩みは少なかったように感じます。  

※ FluxとMVVMのどちらが優れているかという話ではなく、「何をどこに書くか」という観点での認識のズレが起きにくいのがFluxだった、というだけの話です。認識のズレが起きにくいというのは規約が固く明確であるということで、言い換えればMVVMのほうが柔軟性が高く状況に応じて工夫を施しやすいという見方もできると思います。


#### MV*の歴史から見るFlux

MVCではある処理をする際、Controllerが処理の窓口となり、「まずViewにローディングアイコンを出し、次にモデルのデータを更新し、それをViewに反映し…」と宣言的に記述していくことになります。これだと規模が大きくなるにつれ複雑になっていったり、フロントの要件とは相性が悪かったりするので、一部をイベント駆動にしたりデータの持ち方を変えてみたりと試行錯誤した結果が、MV*なのだと認識しています。

### おわりに

FluxはWebアプリケーションの設計方法の選択肢として今後も利用されていくのだと思います。でもFluxは完璧ではありません。  
Fluxの問題点や苦手分野については様々なところで議論されている通りで、アプリケーションが複雑さが増すと対応できない場面も出てくると思います。非同期処理、複雑なドメイン層の表現、アニメーション…。他にも公式ドキュメントには記載のないパターンの対応はどうするのかなど、課題はいろいろあると思います(体感的には山盛りです)。が、それらに立ち向かうためにも、まずは基礎を100％理解していることが必要だと思います。

そんなわけで今回はFlux再入門の話でした。気になる箇所や間違っている箇所がありましたら[@aloerina_](https://twitter.com/aloerina_){:target="_blank"}までご連絡ください。
