---
title: Vue.nextTickのコードリーディング
outline: Fluxとは何なのか、どう実装するのが良いのか…。Fluxを100％理解するために必要なことを整理してみました。「なんとなく理解している」から「ちゃんと理解している」にステップアップするためのFlux再入門話でもあります。
categories: ['JavaScript', 'Vue']
---


### [Vue.nextTick](https://jp.vuejs.org/v2/api/#Vue-nextTick){:target="_blank"}とは？

> callbackを延期し、DOMの更新サイクル後に実行します。DOM更新を待ち受けるために、いくつかのデータを変更した直後に使用してください。

**VueはDOMを非同期に更新する**ため、「DOMを更新した後にその更新済みのDOMに対して何らかの処理をする」といったような場合で`nextTick`は役立ちます。


```js
// single file component

<template>
  <div>{% raw %}{{ message }}{% endraw %}</div>
</template>

<script>
  export default {
    data() {
      return { message: 'default' }
    },
    mounted() {
      this.message = 'hello';
      console.log(this.$el.textContent);    // default この時点ではまだDOMは更新されていない
      this.nextTick(() => {
        console.log(this.$el.textContent);  // hello   DOM更新後にこのコードに到達する 
      });  
    }
  }
</script>
```
dataの値を更新し、それをDOMに反映するよくあるコードです。

このときVueは、dataの更新処理をある程度ため込み、同じDOMを更新する処理が複数件たまった場合はまとめて1回だけ更新します。つまり非同期的に(コードの記述純とは違った順序で)DOMが更新されるということです。

もう少し正確な言葉で言うと、あるイベントループにおいて同じwatcherが複数回更新される場合は、タスクキューには重複除外した1つのタスクが詰められます。そして次のイベントループでタスクを順次捌いていきます。

そしてこの後に、**つまりタスクキューに入った処理が全て完了した後に**何か別の処理を行う方法がnextTickというわけです。


### コードリーディングする

[src/core/util/next-tick.js](https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js)

#### nextTick関数本体

```js
const callbacks = []
let pending = false

/* 中略 */

export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  /* 以下省略 */
```

主要な部分だけピックアップしています。nextTick関数は引数で受け取った`fn`を`callbacks`に詰め、`macroTimerFunc`もしくは`microTimerFunc`を呼び出しています。これらがどんな関数か見てみます。

#### macroTimerFunc と microTimerFunc の定義

```js
// callbacksに詰め込んだ関数を実行する本体
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

// macroTimerFuncの定義
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
  /* 中略 */
} else {
  /* istanbul ignore next */
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

// microTimerFuncの定義
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () => {
    p.then(flushCallbacks)
    /* 省略 */
  }
} 
```
`flushCallbacks`は`callbacks`の中身をコピーして取り出し実行し、`callbacks`を空の状態に戻しているだけです。

`macroTimerFunc`は`setImmediate`もしくは`setTimeout`を使って`flushCallbacks`を呼び出しています。`microTimerFunc`は`Promise.resolve()`を使っていますね。


このような **macro tasks** と **micro tasks** という考え方は[Promises/A+](https://promisesaplus.com/#point-67){:target="_blank"}にも記載があり、どちらも**現在のイベントループ内の全てのタスクの実行完了後に、タスクを追加で実行する手法**を指しています。これにより「DOMの更新後に処理をする」ことが実現されているわけです。

改めて macro tasks と micro tasks の実装を確認してみます。

**macro tasks**

```js
setImmediate(() => {});

// or

setTimeout(() => {}, 0);
```

<p></p>

**micro tasks**

```js
Promise.resolve().then(() => {});
```

<p></p>

どちらの処理もイベントループの後一見どちらでもnextTickの目的は果たせそうですが、Vueはこれらを使い分けていて、その理由がコード内にコメントされています。

> In < 2.4 we used microtasks everywhere, but there are some scenarios where microtasks have too high a priority and fire in between supposedly sequential events (e.g. #4521, #6690) or even between bubbling of the same event (#6566).   
> However, using (macro) tasks everywhere also has subtle problems when state is changed right before repaint (e.g. #6813, out-in transitions).  
> Here we use microtask by default, but expose a way to force (macro) task when needed (e.g. in event handlers attached by v-on).

Vue2.4以前までは micro tasks のみを利用していていましたが、それだと実行タイミングが早すぎてしまうケースがあり、場面に応じて macro tasks と使い分けているということですね。  
言い換えると、これらは実行タイミングが違うということです。

### 検証

macro tasks と micro tasks の実行タイミングはどのように違うのでしょうか？ 簡単な検証用コードで試してみます。
